{"version":3,"file":"index.js","sources":["../src/materials.js","../src/hasBlotterInstance.js","../src/createBlotterComponent.js","../src/SpitColorChannelText.js","../src/FliesText.js","../src/LiquidDistortionText.js","../src/DistortionText.js"],"sourcesContent":["// The shaders are copied from https://github.com/bradley/Blotter/tree/master/build/materials.\n// Since otherwise we need to have material scripts separately in HTML file, now each component can import\n// these materials and update the shader.\n\nexport const channelSplitMaterial = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.PI,\n    BlotterInstance.Assets.Shaders.LineMath,\n    BlotterInstance.Assets.Shaders.Random,\n\n    'const int MAX_STEPS = 200;',\n\n    '// Fix a floating point number to two decimal places',\n    'float toFixedTwo(float f) {',\n    '    return float(int(f * 100.0)) / 100.0;',\n    '}',\n\n    'vec2 motionBlurOffsets(vec2 fragCoord, float deg, float spread) {',\n\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    vec2 centerUv = vec2(0.5);',\n    '    vec2 centerCoord = uResolution.xy * centerUv;',\n\n    '    deg = toFixedTwo(deg);',\n    '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);',\n\n    '    // Find offsets',\n    '    // -------------------------------',\n\n    '    vec2 k = offsetsForCoordAtDistanceOnSlope(spread, slope);',\n    '    if (deg <= 90.0 || deg >= 270.0) {',\n    '        k *= -1.0;',\n    '    }',\n\n    '    return k;',\n    '}',\n\n    'float noiseWithWidthAtUv(float width, vec2 uv) {',\n    '    float noiseModifier = 1.0;',\n    '    if (uAnimateNoise > 0.0) {',\n    '        noiseModifier = sin(uGlobalTime);',\n    '    }',\n\n    '    vec2 noiseRowCol = floor((uv * uResolution.xy) / width);',\n    '    vec2 noiseFragCoord = ((noiseRowCol * width) + (width / 2.0));',\n    '    vec2 noiseUv = noiseFragCoord / uResolution.xy;',\n\n    '    return random(noiseUv * noiseModifier) * 0.125;',\n    '}',\n\n    'vec4 motionBlur(vec2 uv, vec2 blurOffset, float maxOffset) {',\n    '    float noiseWidth = 3.0;',\n    '    float randNoise = noiseWithWidthAtUv(noiseWidth, uv);',\n\n    '    vec4 result = textTexture(uv);',\n\n    '    float maxStepsReached = 0.0;',\n\n    '    // Note: Step by 2 to optimize performance. We conceal lossiness here via applied noise.',\n    '    //   If you do want maximum fidelity, change `i += 2` to `i += 1` below.',\n    '    for (int i = 1; i <= MAX_STEPS; i += 2) {',\n    '        if (abs(float(i)) > maxOffset) { break; }',\n    '        maxStepsReached += 1.0;',\n\n    '        // Divide blurOffset by 2.0 so that motion blur starts half way behind itself',\n    '        //   preventing blur from shoving samples in any direction',\n    '        vec2 offset = (blurOffset / 2.0) - (blurOffset * (float(i) / maxOffset));',\n    '        vec4 stepSample = textTexture(uv + (offset / uResolution.xy));',\n\n    ,\n    '        result += stepSample;',\n    '    }',\n\n    '    if (maxOffset >= 1.0) {',\n    '        result /= maxStepsReached;',\n    '        //result.a = pow(result.a, 2.0); // Apply logarithmic smoothing to alpha',\n    '        result.a -= (randNoise * (1.0 - result.a)); // Apply noise to smoothed alpha',\n    '    }',\n\n    '    return result;',\n    '}',\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {',\n\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    float offset = min(float(MAX_STEPS), uResolution.y * uOffset);',\n\n    '    float slope = normalizedSlope(slopeForDegrees(uRotation), uResolution);',\n\n    '    // We want the blur to be the full offset amount in each direction',\n    '    //   and to adjust with our logarithmic adjustment made later, so multiply by 4',\n    '    float adjustedOffset = offset;// * 4.0;',\n\n    '    vec2 blurOffset = motionBlurOffsets(fragCoord, uRotation, adjustedOffset);',\n\n    '    // Set Starting Points',\n    '    // -------------------------------',\n\n    '    vec2 rUv = uv;',\n    '    vec2 gUv = uv;',\n    '    vec2 bUv = uv;',\n\n    '    vec2 k = offsetsForCoordAtDistanceOnSlope(offset, slope) / uResolution;',\n\n    '    if (uRotation <= 90.0 || uRotation >= 270.0) {',\n    '        rUv += k;',\n    '        bUv -= k;',\n    '    }',\n    '    else {',\n    '        rUv -= k;',\n    '        bUv += k;',\n    '    }',\n\n    '    // Blur and Split Channels',\n    '    // -------------------------------',\n\n    '    vec4 resultR = vec4(0.0);',\n    '    vec4 resultG = vec4(0.0);',\n    '    vec4 resultB = vec4(0.0);',\n\n    '    if (uApplyBlur > 0.0) {',\n    '        resultR = motionBlur(rUv, blurOffset, adjustedOffset);',\n    '        resultG = motionBlur(gUv, blurOffset, adjustedOffset);',\n    '        resultB = motionBlur(bUv, blurOffset, adjustedOffset);',\n    '    } else {',\n    '        resultR = textTexture(rUv);',\n    '        resultG = textTexture(gUv);',\n    '        resultB = textTexture(bUv);',\n    '    }',\n\n    '    float a = resultR.a + resultG.a + resultB.a;',\n\n    '    resultR = normalBlend(resultR, uBlendColor);',\n    '    resultG = normalBlend(resultG, uBlendColor);',\n    '    resultB = normalBlend(resultB, uBlendColor);',\n\n    '    mainImage = vec4(resultR.r, resultG.g, resultB.b, a);',\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uOffset: { type: '1f', value: 0.05 },\n    uRotation: { type: '1f', value: 45.0 },\n    uApplyBlur: { type: '1f', value: 1.0 },\n    uAnimateNoise: { type: '1f', value: 1.0 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n\nexport const fliesMaterial = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.Random,\n\n    'vec2 random2(vec2 p) {',\n    '    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);',\n    '}',\n\n    'float isParticle(out vec3 particleColor, vec2 fragCoord, float pointRadius, float pointCellWidth, float dodge, vec2 dodgePosition, float dodgeSpread, float speed) {    ',\n    '    if (pointCellWidth == 0.0) { return 0.0; };',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    float pointRadiusOfCell = pointRadius / pointCellWidth;',\n\n    '    vec2 totalCellCount = uResolution.xy / pointCellWidth;',\n    '    vec2 cellUv = uv * totalCellCount;',\n\n    '    // Tile the space',\n    '    vec2 iUv = floor(cellUv);',\n    '    vec2 fUv = fract(cellUv);',\n\n    '    float minDist = 1.0;  // minimun distance',\n\n    '    vec4 baseSample = textTexture(cellUv);',\n    '    float maxWeight = 0.0;',\n    '    particleColor = baseSample.rgb;',\n\n    '    for (int y= -1; y <= 1; y++) {',\n    '        for (int x= -1; x <= 1; x++) {',\n    '            // Neighbor place in the grid',\n    '            vec2 neighbor = vec2(float(x), float(y));',\n\n    '            // Random position from current + neighbor place in the grid',\n    '            vec2 point = random2(iUv + neighbor);',\n\n    \"            // Get cell weighting from cell's center alpha\",\n    '            vec2 cellRowCol = floor(fragCoord / pointCellWidth) + neighbor;',\n    '            vec2 cellFragCoord = ((cellRowCol * pointCellWidth) + (pointCellWidth / 2.0));',\n    '            vec4 cellSample = textTexture(cellFragCoord / uResolution.xy);',\n    '            float cellWeight = cellSample.a;',\n\n    '            if (cellWeight < 1.0) {',\n    '               // If the cell is not fully within our text, we should disregard it',\n    '               continue;',\n    '            }',\n\n    '            maxWeight = max(maxWeight, cellWeight);',\n    '            if (cellWeight == maxWeight) {',\n    '                particleColor = cellSample.rgb;',\n    '            }',\n\n    '            float distanceFromDodge = distance(dodgePosition * uResolution.xy, cellFragCoord) / uResolution.y;',\n    '            distanceFromDodge = 1.0 - smoothstep(0.0, dodgeSpread, distanceFromDodge);',\n\n    '            // Apply weighting to noise and dodge if dodge is set to 1.0',\n    '            cellWeight = step(cellWeight, random(cellRowCol)) + (distanceFromDodge * dodge);',\n\n    '            // Animate the point',\n    '            point = 0.5 + 0.75 * sin((uGlobalTime * speed) + 6.2831 * point);',\n\n    '            // Vector between the pixel and the point',\n    '            vec2 diff = neighbor + point - fUv;',\n\n    '            // Distance to the point',\n    '            float dist = length(diff);',\n    '            dist += cellWeight; // Effectively remove point',\n\n    '            // Keep the closer distance',\n    '            minDist = min(minDist, dist);',\n    '        }',\n    '    }',\n\n    '    float pointEasing = pointRadiusOfCell - (1.0 / pointCellWidth);',\n\n    '    float isParticle = 1.0 - smoothstep(pointEasing, pointRadiusOfCell, minDist);',\n\n    '    return isParticle;',\n    '}',\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {',\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    // Convert uPointCellWidth to pixels, keeping it between 1 and the total y resolution of the text',\n    '    // Note: floor uPointCellWidth here so that we dont have half pixel widths on retina displays',\n    '    float pointCellWidth = floor(max(0.0, min(1.0, uPointCellWidth) * uResolution.y));',\n\n    '    // Ensure uPointRadius allow points to exceed the width of their cells',\n    '    float pointRadius = uPointRadius * 0.8;',\n    '    pointRadius = min(pointRadius * pointCellWidth, pointCellWidth);',\n\n    '    float dodge = ceil(uDodge);',\n\n    '    vec3 outColor = vec3(0.0);',\n    '    float point = isParticle(outColor, fragCoord, pointRadius, pointCellWidth, dodge, uDodgePosition, uDodgeSpread, uSpeed);',\n\n    '    mainImage = vec4(outColor, point);',\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uPointCellWidth: { type: '1f', value: 0.04 },\n    uPointRadius: { type: '1f', value: 0.75 },\n    uDodge: { type: '1f', value: 0.0 },\n    uDodgePosition: { type: '2f', value: [0.5, 0.5] },\n    uDodgeSpread: { type: '1f', value: 0.25 },\n    uSpeed: { type: '1f', value: 1.0 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n\nexport const liquidDistortionMaterial = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.Noise3D,\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord )',\n    '{',\n    '    // Setup ========================================================================',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n    '    float z = uSeed + uGlobalTime * uSpeed;',\n\n    '    uv += snoise(vec3(uv, z)) * uVolatility;',\n\n    '    mainImage = textTexture(uv);',\n\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uSpeed: { type: '1f', value: 1.0 },\n    uVolatility: { type: '1f', value: 0.15 },\n    uSeed: { type: '1f', value: 0.1 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n\nexport const distortionText = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.PI,\n    BlotterInstance.Assets.Shaders.LineMath,\n    BlotterInstance.Assets.Shaders.Noise,\n\n    '// Fix a floating point number to two decimal places',\n    'float toFixedTwo(float f) {',\n    '    return float(int(f * 100.0)) / 100.0;',\n    '}',\n\n    '// Via: http://www.iquilezles.org/www/articles/functions/functions.htm',\n    'float impulse(float k, float x) {',\n    '    float h = k * x;',\n    '    return h * exp(1.0 - h);',\n    '}',\n\n    'vec2 waveOffset(vec2 fragCoord, float sineDistortSpread, float sineDistortCycleCount, float sineDistortAmplitude, float noiseDistortVolatility, float noiseDistortAmplitude, vec2 distortPosition, float deg, float speed) {',\n\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    deg = toFixedTwo(deg);',\n\n    '    float centerDistance = 0.5;',\n    '    vec2 centerUv = vec2(centerDistance);',\n    '    vec2 centerCoord = uResolution.xy * centerUv;',\n\n    '    float changeOverTime = uGlobalTime * speed;',\n\n    '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);',\n    '    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0',\n    '    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg), uResolution.xy);',\n\n    '    // Find intersects for line with edges of viewport',\n    '    // -------------------------------',\n\n    '    vec2 edgeIntersectA = vec2(0.0);',\n    '    vec2 edgeIntersectB = vec2(0.0);',\n    '    intersectsOnRectForLine(edgeIntersectA, edgeIntersectB, vec2(0.0), uResolution.xy, centerCoord, slope);',\n    '    float crossSectionLength = distance(edgeIntersectA, edgeIntersectB);',\n\n    '    // Find the threshold for degrees at which our intersectsOnRectForLine function would flip',\n    '    //   intersects A and B because of the order in which it finds them. This is the angle at which',\n    '    //   the y coordinate for the hypotenuse of a right triangle whose oposite adjacent edge runs from',\n    '    //   vec2(0.0, centerCoord.y) to centerCoord and whose opposite edge runs from vec2(0.0, centerCoord.y) to',\n    '    //   vec2(0.0, uResolution.y) exceeeds uResolution.y',\n    '    float thresholdDegA = atan(centerCoord.y / centerCoord.x) * (180.0 / PI);',\n    '    float thresholdDegB = mod(thresholdDegA + 180.0, 360.0);',\n\n    '    vec2 edgeIntersect = vec2(0.0);',\n    '    if (deg < thresholdDegA || deg > thresholdDegB) {',\n    '        edgeIntersect = edgeIntersectA;',\n    '    } else {',\n    '        edgeIntersect = edgeIntersectB;',\n    '    }',\n\n    '    vec2 perpendicularIntersectA = vec2(0.0);',\n    '    vec2 perpendicularIntersectB = vec2(0.0);',\n    '    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), uResolution.xy, centerCoord, perpendicularSlope); ',\n    '    float perpendicularLength = distance(perpendicularIntersectA, perpendicularIntersectA);',\n\n    '    vec2 coordLineIntersect = vec2(0.0);',\n    '    lineLineIntersection(coordLineIntersect, centerCoord, slope, fragCoord, perpendicularSlope);',\n\n    '    // Define placement for distortion ',\n    '    // -------------------------------',\n\n    '    vec2 distortPositionIntersect = vec2(0.0);',\n    '    lineLineIntersection(distortPositionIntersect, distortPosition * uResolution.xy, perpendicularSlope, edgeIntersect, slope);',\n    '    float distortDistanceFromEdge = (distance(edgeIntersect, distortPositionIntersect) / crossSectionLength);// + sineDistortSpread;',\n\n    '    float uvDistanceFromDistort = distance(edgeIntersect, coordLineIntersect) / crossSectionLength;',\n    '    float noiseDistortVarianceAdjuster = uvDistanceFromDistort + changeOverTime;',\n    '    uvDistanceFromDistort += -centerDistance + distortDistanceFromEdge + changeOverTime;',\n    '    uvDistanceFromDistort = mod(uvDistanceFromDistort, 1.0); // For sine, keep distance between 0.0 and 1.0',\n\n    '    // Define sine distortion ',\n    '    // -------------------------------',\n\n    '    float minThreshold = centerDistance - sineDistortSpread;',\n    '    float maxThreshold = centerDistance + sineDistortSpread;',\n\n    '    uvDistanceFromDistort = clamp(((uvDistanceFromDistort - minThreshold)/(maxThreshold - minThreshold)), 0.0, 1.0);',\n    '    if (sineDistortSpread < 0.5) {',\n    '        // Add smoother decay to sin distort when it isnt taking up the full viewport.',\n    '        uvDistanceFromDistort = impulse(uvDistanceFromDistort, uvDistanceFromDistort);',\n    '    }',\n\n    '    float sineDistortion = sin(uvDistanceFromDistort * PI * sineDistortCycleCount) * sineDistortAmplitude;',\n\n    '    // Define noise distortion ',\n    '    // -------------------------------',\n\n    '    float noiseDistortion = noise(noiseDistortVolatility * noiseDistortVarianceAdjuster) * noiseDistortAmplitude;',\n    '    if (noiseDistortVolatility > 0.0) {',\n    '        noiseDistortion -= noiseDistortAmplitude / 2.0; // Adjust primary distort so that it distorts in two directions.',\n    '    }',\n    '    noiseDistortion *= (sineDistortion > 0.0 ? 1.0 : -1.0); // Adjust primary distort to account for sin variance.',\n\n    '    // Combine distortions to find UV offsets ',\n    '    // -------------------------------',\n\n    '    vec2 kV = offsetsForCoordAtDistanceOnSlope(sineDistortion + noiseDistortion, perpendicularSlope);',\n    '    if (deg <= 0.0 || deg >= 180.0) {',\n    '        kV *= -1.0;',\n    '    }',\n\n    '    return kV;',\n    '}',\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord )',\n    '{',\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    // Minor hacks to ensure our waves start horizontal and animating in a downward direction by default.',\n    '    uRotation = mod(uRotation + 270.0, 360.0);',\n    '    uDistortPosition.y = 1.0 - uDistortPosition.y;',\n\n    '    // Distortion',\n    '    // -------------------------------',\n\n    '    vec2 offset = waveOffset(fragCoord, uSineDistortSpread, uSineDistortCycleCount, uSineDistortAmplitude, uNoiseDistortVolatility, uNoiseDistortAmplitude, uDistortPosition, uRotation, uSpeed);',\n\n    '    mainImage = textTexture(uv + offset);',\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uSineDistortSpread: { type: '1f', value: 0.05 },\n    uSineDistortCycleCount: { type: '1f', value: 2.0 },\n    uSineDistortAmplitude: { type: '1f', value: 0.25 },\n    uNoiseDistortVolatility: { type: '1f', value: 20.0 },\n    uNoiseDistortAmplitude: { type: '1f', value: 0.01 },\n    uDistortPosition: { type: '2f', value: [0.5, 0.5] },\n    uRotation: { type: '1f', value: 170.0 },\n    uSpeed: { type: '1f', value: 0.08 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n","export const hasBlotterInstance = () => {\n  if (typeof window !== undefined && window.Blotter === undefined) {\n    throw Error(`\n              Couldn't find a Blotter.js script. Place this script in your HTML file to instantiate Blotter module and WebGL context.\n          `);\n  }\n};\n","import React from 'react'\nimport { hasBlotterInstance } from './hasBlotterInstance'\n\n// A high order component that creates a blotter text component using the input parameters\nexport const createBlotterComponent = ({\n\t// A material is a function that returns a shader string and uniforms to update the effects\n\tmaterial,\n\t// setMaterialValues is a function that takes a shader material and input props, and updates the materials with those props\n\t// This is invoked on first mount and subsequent state updates\n\tsetMaterialValues,\n\t// Default props of the component\n\tdefaultProps,\n\t// Component's display name (useful for debugging)\n\tdisplayName,\n}) => {\n\tclass BlotterComponent extends React.Component {\n\t\tmaterial = null\n\n\t\tstatic displayName = displayName\n\n\t\tstatic defaultProps = defaultProps\n\n\t\tcomponentDidMount() {\n\t\t\t// Check if the blotter instance is initiated otherwise throw an error\n\t\t\thasBlotterInstance()\n\n\t\t\t// TODO: Publish a private fork of Blotter with customised build setup\n\t\t\tconst BlotterInstance = window.Blotter\n\n\t\t\t// Each material function returns an object which includes a shader string and uniforms to update the effects in shader\n\t\t\tconst { shader, uniforms } = material(BlotterInstance)\n\n\t\t\tthis.material = new BlotterInstance.ShaderMaterial(shader, {\n\t\t\t\tuniforms,\n\t\t\t})\n\n\t\t\t// Create a text object with style properties\n\t\t\tconst text = new BlotterInstance.Text(this.props.text, {\n\t\t\t\tfamily: this.props.fontFamily,\n\t\t\t\tsize: this.props.fontSize,\n\t\t\t\tfill: this.props.fill,\n\t\t\t\tpaddingLeft: this.props.paddingLeft,\n\t\t\t\tpaddingRight: this.props.paddingRight,\n\t\t\t\tpaddingBottom: this.props.paddingBottom,\n\t\t\t\tpaddingTop: this.props.paddingTop,\n\t\t\t\tleading: this.props.lineHeight,\n\t\t\t\tweight: this.props.fontWeight,\n\t\t\t\tstyle: this.props.fontStyle,\n\t\t\t})\n\n\t\t\tconst blotter = new Blotter(this.material, {\n\t\t\t\ttexts: text,\n\t\t\t})\n\n\t\t\tconst textObj = blotter.forText(text)\n\n\t\t\t// Append the text canvas to a user defined element id or wrapper id\n\t\t\tthis.props.appendTo && typeof this.props.appendTo === 'string'\n\t\t\t\t? this.appendText(textObj, this.props.appendTo)\n\t\t\t\t: this.appendText(textObj, this.props.id)\n\n\t\t\t// Invoke the prop callback with rendering context. Useful if you want to update the canvas with other third party libs.\n\t\t\tthis.props.get2dContext && typeof this.props.get2dContext === 'function'\n\t\t\t\t? this.props.get2dContext(textObj.context)\n\t\t\t\t: null\n\n\t\t\t// On first mount, set the material values (this is optional)\n\t\t\tsetMaterialValues(this.material, this.props)\n\t\t}\n\n\t\tcomponentDidUpdate() {\n\t\t\t// Update the shader material with new values (or uniforms)\n\t\t\tsetMaterialValues(this.material, this.props)\n\t\t}\n\n\t\tappendText = (textObj, id) => {\n\t\t\tconst element = document.getElementById(id)\n\n\t\t\tif (element) {\n\t\t\t\ttextObj.appendTo(element)\n\t\t\t} else {\n\t\t\t\tconsole.error(`Couldn't find an element with id '${id}'.`)\n\t\t\t}\n\t\t}\n\n\t\trender() {\n\t\t\tif (this.props.appendTo) return null\n\n\t\t\treturn <div id={this.props.id} style={this.props.wrapperStyles} />\n\t\t}\n\t}\n\n\treturn BlotterComponent\n}\n","import { channelSplitMaterial } from './materials';\n\nimport { createBlotterComponent } from './createBlotterComponent';\n\nexport const SplitColorChannelText = createBlotterComponent({\n  material: channelSplitMaterial,\n  defaultProps: {\n    id: 'channel-split-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    rotation: 0.0,\n    rgbOffset: 0.05,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5\n  },\n  displayName: 'SplitColorChannel',\n  setMaterialValues: (material, props) => {\n    material.uniforms.uOffset.value = parseFloat(props.rgbOffset);\n    material.uniforms.uRotation.value = parseFloat(props.rotation);\n    material.uniforms.uApplyBlur.value = props.addBlur ? 1.0 : 0.0;\n    material.uniforms.uAnimateNoise.value = props.addNoise ? 1.0 : 0.0;\n  }\n});\n","import { fliesMaterial } from './materials';\nimport { createBlotterComponent } from './createBlotterComponent';\n\nexport const FliesText = createBlotterComponent({\n  material: fliesMaterial,\n  defaultProps: {\n    cellWidth: 0.04,\n    cellRadius: 0.5,\n    speed: 2.0,\n    dodge: false,\n    dodgeX: 0.5,\n    dodgeY: 0.8,\n    dodgeSpread: 0.75,\n    id: 'flies-text-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5\n  },\n  displayName: 'FliesText',\n  setMaterialValues: (material, props) => {\n    material.uniforms.uPointCellWidth.value = parseFloat(props.cellWidth);\n    material.uniforms.uPointRadius.value = parseFloat(props.cellRadius);\n    material.uniforms.uSpeed.value = parseFloat(props.speed);\n    material.uniforms.uDodge.value = props.dodge ? 1.0 : 0.0;\n    material.uniforms.uDodgePosition.value = [\n      parseFloat(props.dodgeX),\n      parseFloat(props.dodgeY)\n    ];\n    material.uniforms.uDodgeSpread.value = parseFloat(props.dodgeSpread);\n  }\n});\n","import { createBlotterComponent } from './createBlotterComponent';\nimport { liquidDistortionMaterial } from './materials';\n\nexport const LiquidDistortionText = createBlotterComponent({\n  defaultProps: {\n    id: 'liquid-distortion-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5,\n    speed: 1.5,\n    volatility: 0.04\n  },\n  displayName: 'LiquidDistortionText',\n  setMaterialValues: (material, props) => {\n    material.uniforms.uSpeed.value = parseFloat(props.speed);\n    material.uniforms.uVolatility.value = parseFloat(props.volatility);\n  },\n  material: liquidDistortionMaterial\n});\n","import { createBlotterComponent } from './createBlotterComponent';\nimport { distortionText } from './materials';\n\nexport const DistortionText = createBlotterComponent({\n  material: distortionText,\n  defaultProps: {\n    id: 'distortion-text-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    rotation: 0.0,\n    rgbOffset: 0.05,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    speed: 0.084,\n    rotation: 120.0,\n    distortX: 0.06,\n    distortY: 0.09,\n    noiseAmplitude: 0.101,\n    noiseVolatility: 8\n  },\n  setMaterialValues: (material, props) => {\n    material.uniforms.uNoiseDistortVolatility.value = props.noiseVolatility;\n    material.uniforms.uNoiseDistortAmplitude.value = props.noiseAmplitude;\n    material.uniforms.uDistortPosition.value = [props.distortX, props.distortY];\n    material.uniforms.uRotation.value = props.rotation;\n    material.uniforms.uSpeed.value = props.speed;\n    material.uniforms.uSineDistortSpread.value = 0;\n    material.uniforms.uSineDistortCycleCount.value = 0;\n    material.uniforms.uSineDistortAmplitude.value = 0;\n  },\n  displayName: 'DistortionText'\n});\n"],"names":["channelSplitMaterial","shader","BlotterInstance","Assets","Shaders","PI","LineMath","Random","join","uniforms","type","value","fliesMaterial","liquidDistortionMaterial","Noise3D","distortionText","Noise","hasBlotterInstance","window","undefined","Blotter","Error","createBlotterComponent","material","setMaterialValues","defaultProps","displayName","BlotterComponent","appendText","textObj","id","element","document","getElementById","appendTo","error","ShaderMaterial","text","Text","props","fontFamily","fontSize","fill","paddingLeft","paddingRight","paddingBottom","paddingTop","lineHeight","fontWeight","fontStyle","blotter","forText","get2dContext","context","wrapperStyles","React","Component","SplitColorChannelText","uOffset","parseFloat","rgbOffset","uRotation","rotation","uApplyBlur","addBlur","uAnimateNoise","addNoise","FliesText","uPointCellWidth","cellWidth","uPointRadius","cellRadius","uSpeed","speed","uDodge","dodge","uDodgePosition","dodgeX","dodgeY","uDodgeSpread","dodgeSpread","LiquidDistortionText","uVolatility","volatility","DistortionText","uNoiseDistortVolatility","noiseVolatility","uNoiseDistortAmplitude","noiseAmplitude","uDistortPosition","distortX","distortY","uSineDistortSpread","uSineDistortCycleCount","uSineDistortAmplitude"],"mappings":"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"}