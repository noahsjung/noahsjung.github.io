import React from 'react';

// The shaders are copied from https://github.com/bradley/Blotter/tree/master/build/materials.
// Since otherwise we need to have material scripts separately in HTML file, now each component can import
// these materials and update the shader.

var channelSplitMaterial = function channelSplitMaterial(BlotterInstance) {
  var shader = [BlotterInstance.Assets.Shaders.PI, BlotterInstance.Assets.Shaders.LineMath, BlotterInstance.Assets.Shaders.Random, 'const int MAX_STEPS = 200;', '// Fix a floating point number to two decimal places', 'float toFixedTwo(float f) {', '    return float(int(f * 100.0)) / 100.0;', '}', 'vec2 motionBlurOffsets(vec2 fragCoord, float deg, float spread) {', '    // Setup', '    // -------------------------------', '    vec2 centerUv = vec2(0.5);', '    vec2 centerCoord = uResolution.xy * centerUv;', '    deg = toFixedTwo(deg);', '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);', '    // Find offsets', '    // -------------------------------', '    vec2 k = offsetsForCoordAtDistanceOnSlope(spread, slope);', '    if (deg <= 90.0 || deg >= 270.0) {', '        k *= -1.0;', '    }', '    return k;', '}', 'float noiseWithWidthAtUv(float width, vec2 uv) {', '    float noiseModifier = 1.0;', '    if (uAnimateNoise > 0.0) {', '        noiseModifier = sin(uGlobalTime);', '    }', '    vec2 noiseRowCol = floor((uv * uResolution.xy) / width);', '    vec2 noiseFragCoord = ((noiseRowCol * width) + (width / 2.0));', '    vec2 noiseUv = noiseFragCoord / uResolution.xy;', '    return random(noiseUv * noiseModifier) * 0.125;', '}', 'vec4 motionBlur(vec2 uv, vec2 blurOffset, float maxOffset) {', '    float noiseWidth = 3.0;', '    float randNoise = noiseWithWidthAtUv(noiseWidth, uv);', '    vec4 result = textTexture(uv);', '    float maxStepsReached = 0.0;', '    // Note: Step by 2 to optimize performance. We conceal lossiness here via applied noise.', '    //   If you do want maximum fidelity, change `i += 2` to `i += 1` below.', '    for (int i = 1; i <= MAX_STEPS; i += 2) {', '        if (abs(float(i)) > maxOffset) { break; }', '        maxStepsReached += 1.0;', '        // Divide blurOffset by 2.0 so that motion blur starts half way behind itself', '        //   preventing blur from shoving samples in any direction', '        vec2 offset = (blurOffset / 2.0) - (blurOffset * (float(i) / maxOffset));', '        vec4 stepSample = textTexture(uv + (offset / uResolution.xy));',, '        result += stepSample;', '    }', '    if (maxOffset >= 1.0) {', '        result /= maxStepsReached;', '        //result.a = pow(result.a, 2.0); // Apply logarithmic smoothing to alpha', '        result.a -= (randNoise * (1.0 - result.a)); // Apply noise to smoothed alpha', '    }', '    return result;', '}', 'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {', '    // Setup', '    // -------------------------------', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    float offset = min(float(MAX_STEPS), uResolution.y * uOffset);', '    float slope = normalizedSlope(slopeForDegrees(uRotation), uResolution);', '    // We want the blur to be the full offset amount in each direction', '    //   and to adjust with our logarithmic adjustment made later, so multiply by 4', '    float adjustedOffset = offset;// * 4.0;', '    vec2 blurOffset = motionBlurOffsets(fragCoord, uRotation, adjustedOffset);', '    // Set Starting Points', '    // -------------------------------', '    vec2 rUv = uv;', '    vec2 gUv = uv;', '    vec2 bUv = uv;', '    vec2 k = offsetsForCoordAtDistanceOnSlope(offset, slope) / uResolution;', '    if (uRotation <= 90.0 || uRotation >= 270.0) {', '        rUv += k;', '        bUv -= k;', '    }', '    else {', '        rUv -= k;', '        bUv += k;', '    }', '    // Blur and Split Channels', '    // -------------------------------', '    vec4 resultR = vec4(0.0);', '    vec4 resultG = vec4(0.0);', '    vec4 resultB = vec4(0.0);', '    if (uApplyBlur > 0.0) {', '        resultR = motionBlur(rUv, blurOffset, adjustedOffset);', '        resultG = motionBlur(gUv, blurOffset, adjustedOffset);', '        resultB = motionBlur(bUv, blurOffset, adjustedOffset);', '    } else {', '        resultR = textTexture(rUv);', '        resultG = textTexture(gUv);', '        resultB = textTexture(bUv);', '    }', '    float a = resultR.a + resultG.a + resultB.a;', '    resultR = normalBlend(resultR, uBlendColor);', '    resultG = normalBlend(resultG, uBlendColor);', '    resultB = normalBlend(resultB, uBlendColor);', '    mainImage = vec4(resultR.r, resultG.g, resultB.b, a);', '}'].join('\n');

  var uniforms = {
    uOffset: { type: '1f', value: 0.05 },
    uRotation: { type: '1f', value: 45.0 },
    uApplyBlur: { type: '1f', value: 1.0 },
    uAnimateNoise: { type: '1f', value: 1.0 }
  };

  return {
    shader: shader,
    uniforms: uniforms
  };
};

var fliesMaterial = function fliesMaterial(BlotterInstance) {
  var shader = [BlotterInstance.Assets.Shaders.Random, 'vec2 random2(vec2 p) {', '    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);', '}', 'float isParticle(out vec3 particleColor, vec2 fragCoord, float pointRadius, float pointCellWidth, float dodge, vec2 dodgePosition, float dodgeSpread, float speed) {    ', '    if (pointCellWidth == 0.0) { return 0.0; };', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    float pointRadiusOfCell = pointRadius / pointCellWidth;', '    vec2 totalCellCount = uResolution.xy / pointCellWidth;', '    vec2 cellUv = uv * totalCellCount;', '    // Tile the space', '    vec2 iUv = floor(cellUv);', '    vec2 fUv = fract(cellUv);', '    float minDist = 1.0;  // minimun distance', '    vec4 baseSample = textTexture(cellUv);', '    float maxWeight = 0.0;', '    particleColor = baseSample.rgb;', '    for (int y= -1; y <= 1; y++) {', '        for (int x= -1; x <= 1; x++) {', '            // Neighbor place in the grid', '            vec2 neighbor = vec2(float(x), float(y));', '            // Random position from current + neighbor place in the grid', '            vec2 point = random2(iUv + neighbor);', "            // Get cell weighting from cell's center alpha", '            vec2 cellRowCol = floor(fragCoord / pointCellWidth) + neighbor;', '            vec2 cellFragCoord = ((cellRowCol * pointCellWidth) + (pointCellWidth / 2.0));', '            vec4 cellSample = textTexture(cellFragCoord / uResolution.xy);', '            float cellWeight = cellSample.a;', '            if (cellWeight < 1.0) {', '               // If the cell is not fully within our text, we should disregard it', '               continue;', '            }', '            maxWeight = max(maxWeight, cellWeight);', '            if (cellWeight == maxWeight) {', '                particleColor = cellSample.rgb;', '            }', '            float distanceFromDodge = distance(dodgePosition * uResolution.xy, cellFragCoord) / uResolution.y;', '            distanceFromDodge = 1.0 - smoothstep(0.0, dodgeSpread, distanceFromDodge);', '            // Apply weighting to noise and dodge if dodge is set to 1.0', '            cellWeight = step(cellWeight, random(cellRowCol)) + (distanceFromDodge * dodge);', '            // Animate the point', '            point = 0.5 + 0.75 * sin((uGlobalTime * speed) + 6.2831 * point);', '            // Vector between the pixel and the point', '            vec2 diff = neighbor + point - fUv;', '            // Distance to the point', '            float dist = length(diff);', '            dist += cellWeight; // Effectively remove point', '            // Keep the closer distance', '            minDist = min(minDist, dist);', '        }', '    }', '    float pointEasing = pointRadiusOfCell - (1.0 / pointCellWidth);', '    float isParticle = 1.0 - smoothstep(pointEasing, pointRadiusOfCell, minDist);', '    return isParticle;', '}', 'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    // Convert uPointCellWidth to pixels, keeping it between 1 and the total y resolution of the text', '    // Note: floor uPointCellWidth here so that we dont have half pixel widths on retina displays', '    float pointCellWidth = floor(max(0.0, min(1.0, uPointCellWidth) * uResolution.y));', '    // Ensure uPointRadius allow points to exceed the width of their cells', '    float pointRadius = uPointRadius * 0.8;', '    pointRadius = min(pointRadius * pointCellWidth, pointCellWidth);', '    float dodge = ceil(uDodge);', '    vec3 outColor = vec3(0.0);', '    float point = isParticle(outColor, fragCoord, pointRadius, pointCellWidth, dodge, uDodgePosition, uDodgeSpread, uSpeed);', '    mainImage = vec4(outColor, point);', '}'].join('\n');

  var uniforms = {
    uPointCellWidth: { type: '1f', value: 0.04 },
    uPointRadius: { type: '1f', value: 0.75 },
    uDodge: { type: '1f', value: 0.0 },
    uDodgePosition: { type: '2f', value: [0.5, 0.5] },
    uDodgeSpread: { type: '1f', value: 0.25 },
    uSpeed: { type: '1f', value: 1.0 }
  };

  return {
    shader: shader,
    uniforms: uniforms
  };
};

var liquidDistortionMaterial = function liquidDistortionMaterial(BlotterInstance) {
  var shader = [BlotterInstance.Assets.Shaders.Noise3D, 'void mainImage( out vec4 mainImage, in vec2 fragCoord )', '{', '    // Setup ========================================================================', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    float z = uSeed + uGlobalTime * uSpeed;', '    uv += snoise(vec3(uv, z)) * uVolatility;', '    mainImage = textTexture(uv);', '}'].join('\n');

  var uniforms = {
    uSpeed: { type: '1f', value: 1.0 },
    uVolatility: { type: '1f', value: 0.15 },
    uSeed: { type: '1f', value: 0.1 }
  };

  return {
    shader: shader,
    uniforms: uniforms
  };
};

var distortionText = function distortionText(BlotterInstance) {
  var shader = [BlotterInstance.Assets.Shaders.PI, BlotterInstance.Assets.Shaders.LineMath, BlotterInstance.Assets.Shaders.Noise, '// Fix a floating point number to two decimal places', 'float toFixedTwo(float f) {', '    return float(int(f * 100.0)) / 100.0;', '}', '// Via: http://www.iquilezles.org/www/articles/functions/functions.htm', 'float impulse(float k, float x) {', '    float h = k * x;', '    return h * exp(1.0 - h);', '}', 'vec2 waveOffset(vec2 fragCoord, float sineDistortSpread, float sineDistortCycleCount, float sineDistortAmplitude, float noiseDistortVolatility, float noiseDistortAmplitude, vec2 distortPosition, float deg, float speed) {', '    // Setup', '    // -------------------------------', '    deg = toFixedTwo(deg);', '    float centerDistance = 0.5;', '    vec2 centerUv = vec2(centerDistance);', '    vec2 centerCoord = uResolution.xy * centerUv;', '    float changeOverTime = uGlobalTime * speed;', '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);', '    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0', '    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg), uResolution.xy);', '    // Find intersects for line with edges of viewport', '    // -------------------------------', '    vec2 edgeIntersectA = vec2(0.0);', '    vec2 edgeIntersectB = vec2(0.0);', '    intersectsOnRectForLine(edgeIntersectA, edgeIntersectB, vec2(0.0), uResolution.xy, centerCoord, slope);', '    float crossSectionLength = distance(edgeIntersectA, edgeIntersectB);', '    // Find the threshold for degrees at which our intersectsOnRectForLine function would flip', '    //   intersects A and B because of the order in which it finds them. This is the angle at which', '    //   the y coordinate for the hypotenuse of a right triangle whose oposite adjacent edge runs from', '    //   vec2(0.0, centerCoord.y) to centerCoord and whose opposite edge runs from vec2(0.0, centerCoord.y) to', '    //   vec2(0.0, uResolution.y) exceeeds uResolution.y', '    float thresholdDegA = atan(centerCoord.y / centerCoord.x) * (180.0 / PI);', '    float thresholdDegB = mod(thresholdDegA + 180.0, 360.0);', '    vec2 edgeIntersect = vec2(0.0);', '    if (deg < thresholdDegA || deg > thresholdDegB) {', '        edgeIntersect = edgeIntersectA;', '    } else {', '        edgeIntersect = edgeIntersectB;', '    }', '    vec2 perpendicularIntersectA = vec2(0.0);', '    vec2 perpendicularIntersectB = vec2(0.0);', '    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), uResolution.xy, centerCoord, perpendicularSlope); ', '    float perpendicularLength = distance(perpendicularIntersectA, perpendicularIntersectA);', '    vec2 coordLineIntersect = vec2(0.0);', '    lineLineIntersection(coordLineIntersect, centerCoord, slope, fragCoord, perpendicularSlope);', '    // Define placement for distortion ', '    // -------------------------------', '    vec2 distortPositionIntersect = vec2(0.0);', '    lineLineIntersection(distortPositionIntersect, distortPosition * uResolution.xy, perpendicularSlope, edgeIntersect, slope);', '    float distortDistanceFromEdge = (distance(edgeIntersect, distortPositionIntersect) / crossSectionLength);// + sineDistortSpread;', '    float uvDistanceFromDistort = distance(edgeIntersect, coordLineIntersect) / crossSectionLength;', '    float noiseDistortVarianceAdjuster = uvDistanceFromDistort + changeOverTime;', '    uvDistanceFromDistort += -centerDistance + distortDistanceFromEdge + changeOverTime;', '    uvDistanceFromDistort = mod(uvDistanceFromDistort, 1.0); // For sine, keep distance between 0.0 and 1.0', '    // Define sine distortion ', '    // -------------------------------', '    float minThreshold = centerDistance - sineDistortSpread;', '    float maxThreshold = centerDistance + sineDistortSpread;', '    uvDistanceFromDistort = clamp(((uvDistanceFromDistort - minThreshold)/(maxThreshold - minThreshold)), 0.0, 1.0);', '    if (sineDistortSpread < 0.5) {', '        // Add smoother decay to sin distort when it isnt taking up the full viewport.', '        uvDistanceFromDistort = impulse(uvDistanceFromDistort, uvDistanceFromDistort);', '    }', '    float sineDistortion = sin(uvDistanceFromDistort * PI * sineDistortCycleCount) * sineDistortAmplitude;', '    // Define noise distortion ', '    // -------------------------------', '    float noiseDistortion = noise(noiseDistortVolatility * noiseDistortVarianceAdjuster) * noiseDistortAmplitude;', '    if (noiseDistortVolatility > 0.0) {', '        noiseDistortion -= noiseDistortAmplitude / 2.0; // Adjust primary distort so that it distorts in two directions.', '    }', '    noiseDistortion *= (sineDistortion > 0.0 ? 1.0 : -1.0); // Adjust primary distort to account for sin variance.', '    // Combine distortions to find UV offsets ', '    // -------------------------------', '    vec2 kV = offsetsForCoordAtDistanceOnSlope(sineDistortion + noiseDistortion, perpendicularSlope);', '    if (deg <= 0.0 || deg >= 180.0) {', '        kV *= -1.0;', '    }', '    return kV;', '}', 'void mainImage( out vec4 mainImage, in vec2 fragCoord )', '{', '    // Setup', '    // -------------------------------', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    // Minor hacks to ensure our waves start horizontal and animating in a downward direction by default.', '    uRotation = mod(uRotation + 270.0, 360.0);', '    uDistortPosition.y = 1.0 - uDistortPosition.y;', '    // Distortion', '    // -------------------------------', '    vec2 offset = waveOffset(fragCoord, uSineDistortSpread, uSineDistortCycleCount, uSineDistortAmplitude, uNoiseDistortVolatility, uNoiseDistortAmplitude, uDistortPosition, uRotation, uSpeed);', '    mainImage = textTexture(uv + offset);', '}'].join('\n');

  var uniforms = {
    uSineDistortSpread: { type: '1f', value: 0.05 },
    uSineDistortCycleCount: { type: '1f', value: 2.0 },
    uSineDistortAmplitude: { type: '1f', value: 0.25 },
    uNoiseDistortVolatility: { type: '1f', value: 20.0 },
    uNoiseDistortAmplitude: { type: '1f', value: 0.01 },
    uDistortPosition: { type: '2f', value: [0.5, 0.5] },
    uRotation: { type: '1f', value: 170.0 },
    uSpeed: { type: '1f', value: 0.08 }
  };

  return {
    shader: shader,
    uniforms: uniforms
  };
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var hasBlotterInstance = function hasBlotterInstance() {
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefined && window.Blotter === undefined) {
    throw Error("\n              Couldn't find a Blotter.js script. Place this script in your HTML file to instantiate Blotter module and WebGL context.\n          ");
  }
};

// A high order component that creates a blotter text component using the input parameters
var createBlotterComponent = function createBlotterComponent(_ref) {
	var material = _ref.material,
	    setMaterialValues = _ref.setMaterialValues,
	    defaultProps = _ref.defaultProps,
	    displayName = _ref.displayName;

	var BlotterComponent = function (_React$Component) {
		inherits(BlotterComponent, _React$Component);

		function BlotterComponent() {
			var _ref2;

			var _temp, _this, _ret;

			classCallCheck(this, BlotterComponent);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = BlotterComponent.__proto__ || Object.getPrototypeOf(BlotterComponent)).call.apply(_ref2, [this].concat(args))), _this), _this.material = null, _this.appendText = function (textObj, id) {
				var element = document.getElementById(id);

				if (element) {
					textObj.appendTo(element);
				} else {
					console.error('Couldn\'t find an element with id \'' + id + '\'.');
				}
			}, _temp), possibleConstructorReturn(_this, _ret);
		}

		createClass(BlotterComponent, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				// Check if the blotter instance is initiated otherwise throw an error
				hasBlotterInstance();

				// TODO: Publish a private fork of Blotter with customised build setup
				var BlotterInstance = window.Blotter;

				// Each material function returns an object which includes a shader string and uniforms to update the effects in shader

				var _material = material(BlotterInstance),
				    shader = _material.shader,
				    uniforms = _material.uniforms;

				this.material = new BlotterInstance.ShaderMaterial(shader, {
					uniforms: uniforms
				});

				// Create a text object with style properties
				var text = new BlotterInstance.Text(this.props.text, {
					family: this.props.fontFamily,
					size: this.props.fontSize,
					fill: this.props.fill,
					paddingLeft: this.props.paddingLeft,
					paddingRight: this.props.paddingRight,
					paddingBottom: this.props.paddingBottom,
					paddingTop: this.props.paddingTop,
					leading: this.props.lineHeight,
					weight: this.props.fontWeight,
					style: this.props.fontStyle
				});

				var blotter = new Blotter(this.material, {
					texts: text
				});

				var textObj = blotter.forText(text);

				// Append the text canvas to a user defined element id or wrapper id
				this.props.appendTo && typeof this.props.appendTo === 'string' ? this.appendText(textObj, this.props.appendTo) : this.appendText(textObj, this.props.id);

				// Invoke the prop callback with rendering context. Useful if you want to update the canvas with other third party libs.
				this.props.get2dContext && typeof this.props.get2dContext === 'function' ? this.props.get2dContext(textObj.context) : null;

				// On first mount, set the material values (this is optional)
				setMaterialValues(this.material, this.props);
			}
		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate() {
				// Update the shader material with new values (or uniforms)
				setMaterialValues(this.material, this.props);
			}
		}, {
			key: 'render',
			value: function render() {
				if (this.props.appendTo) return null;

				return React.createElement('div', { id: this.props.id, style: this.props.wrapperStyles });
			}
		}]);
		return BlotterComponent;
	}(React.Component);

	BlotterComponent.displayName = displayName;
	BlotterComponent.defaultProps = defaultProps;


	return BlotterComponent;
};

var SplitColorChannelText = createBlotterComponent({
  material: channelSplitMaterial,
  defaultProps: {
    id: 'channel-split-component',
    text: 'Hello World',
    fontFamily: 'sans-serif',
    fontSize: 45,
    fontWeight: 400,
    rotation: 0.0,
    rgbOffset: 0.05,
    fill: '#4f4f4f',
    fontStyle: 'normal',
    paddingBottom: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingLeft: 0,
    lineHeight: 1.5
  },
  displayName: 'SplitColorChannel',
  setMaterialValues: function setMaterialValues(material, props) {
    material.uniforms.uOffset.value = parseFloat(props.rgbOffset);
    material.uniforms.uRotation.value = parseFloat(props.rotation);
    material.uniforms.uApplyBlur.value = props.addBlur ? 1.0 : 0.0;
    material.uniforms.uAnimateNoise.value = props.addNoise ? 1.0 : 0.0;
  }
});

var FliesText = createBlotterComponent({
  material: fliesMaterial,
  defaultProps: {
    cellWidth: 0.04,
    cellRadius: 0.5,
    speed: 2.0,
    dodge: false,
    dodgeX: 0.5,
    dodgeY: 0.8,
    dodgeSpread: 0.75,
    id: 'flies-text-component',
    text: 'Hello World',
    fontFamily: 'sans-serif',
    fontSize: 45,
    fontWeight: 400,
    fill: '#4f4f4f',
    fontStyle: 'normal',
    paddingBottom: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingLeft: 0,
    lineHeight: 1.5
  },
  displayName: 'FliesText',
  setMaterialValues: function setMaterialValues(material, props) {
    material.uniforms.uPointCellWidth.value = parseFloat(props.cellWidth);
    material.uniforms.uPointRadius.value = parseFloat(props.cellRadius);
    material.uniforms.uSpeed.value = parseFloat(props.speed);
    material.uniforms.uDodge.value = props.dodge ? 1.0 : 0.0;
    material.uniforms.uDodgePosition.value = [parseFloat(props.dodgeX), parseFloat(props.dodgeY)];
    material.uniforms.uDodgeSpread.value = parseFloat(props.dodgeSpread);
  }
});

var LiquidDistortionText = createBlotterComponent({
  defaultProps: {
    id: 'liquid-distortion-component',
    text: 'Hello World',
    fontFamily: 'sans-serif',
    fontSize: 45,
    fontWeight: 400,
    fill: '#4f4f4f',
    fontStyle: 'normal',
    paddingBottom: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingLeft: 0,
    lineHeight: 1.5,
    speed: 1.5,
    volatility: 0.04
  },
  displayName: 'LiquidDistortionText',
  setMaterialValues: function setMaterialValues(material, props) {
    material.uniforms.uSpeed.value = parseFloat(props.speed);
    material.uniforms.uVolatility.value = parseFloat(props.volatility);
  },
  material: liquidDistortionMaterial
});

var _defaultProps;

var DistortionText = createBlotterComponent({
  material: distortionText,
  defaultProps: (_defaultProps = {
    id: 'distortion-text-component',
    text: 'Hello World',
    fontFamily: 'sans-serif',
    fontSize: 45,
    fontWeight: 400,
    rotation: 0.0,
    rgbOffset: 0.05,
    fill: '#4f4f4f',
    fontStyle: 'normal',
    paddingBottom: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingLeft: 0,
    speed: 0.084
  }, defineProperty(_defaultProps, 'rotation', 120.0), defineProperty(_defaultProps, 'distortX', 0.06), defineProperty(_defaultProps, 'distortY', 0.09), defineProperty(_defaultProps, 'noiseAmplitude', 0.101), defineProperty(_defaultProps, 'noiseVolatility', 8), _defaultProps),
  setMaterialValues: function setMaterialValues(material, props) {
    material.uniforms.uNoiseDistortVolatility.value = props.noiseVolatility;
    material.uniforms.uNoiseDistortAmplitude.value = props.noiseAmplitude;
    material.uniforms.uDistortPosition.value = [props.distortX, props.distortY];
    material.uniforms.uRotation.value = props.rotation;
    material.uniforms.uSpeed.value = props.speed;
    material.uniforms.uSineDistortSpread.value = 0;
    material.uniforms.uSineDistortCycleCount.value = 0;
    material.uniforms.uSineDistortAmplitude.value = 0;
  },
  displayName: 'DistortionText'
});

export { SplitColorChannelText, FliesText, LiquidDistortionText, DistortionText };
//# sourceMappingURL=index.es.js.map
