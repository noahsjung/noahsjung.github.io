{"ast":null,"code":"import React from 'react'; // The shaders are copied from https://github.com/bradley/Blotter/tree/master/build/materials.\n// Since otherwise we need to have material scripts separately in HTML file, now each component can import\n// these materials and update the shader.\n\nvar channelSplitMaterial = function channelSplitMaterial(BlotterInstance) {\n  var shader = [BlotterInstance.Assets.Shaders.PI, BlotterInstance.Assets.Shaders.LineMath, BlotterInstance.Assets.Shaders.Random, 'const int MAX_STEPS = 200;', '// Fix a floating point number to two decimal places', 'float toFixedTwo(float f) {', '    return float(int(f * 100.0)) / 100.0;', '}', 'vec2 motionBlurOffsets(vec2 fragCoord, float deg, float spread) {', '    // Setup', '    // -------------------------------', '    vec2 centerUv = vec2(0.5);', '    vec2 centerCoord = uResolution.xy * centerUv;', '    deg = toFixedTwo(deg);', '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);', '    // Find offsets', '    // -------------------------------', '    vec2 k = offsetsForCoordAtDistanceOnSlope(spread, slope);', '    if (deg <= 90.0 || deg >= 270.0) {', '        k *= -1.0;', '    }', '    return k;', '}', 'float noiseWithWidthAtUv(float width, vec2 uv) {', '    float noiseModifier = 1.0;', '    if (uAnimateNoise > 0.0) {', '        noiseModifier = sin(uGlobalTime);', '    }', '    vec2 noiseRowCol = floor((uv * uResolution.xy) / width);', '    vec2 noiseFragCoord = ((noiseRowCol * width) + (width / 2.0));', '    vec2 noiseUv = noiseFragCoord / uResolution.xy;', '    return random(noiseUv * noiseModifier) * 0.125;', '}', 'vec4 motionBlur(vec2 uv, vec2 blurOffset, float maxOffset) {', '    float noiseWidth = 3.0;', '    float randNoise = noiseWithWidthAtUv(noiseWidth, uv);', '    vec4 result = textTexture(uv);', '    float maxStepsReached = 0.0;', '    // Note: Step by 2 to optimize performance. We conceal lossiness here via applied noise.', '    //   If you do want maximum fidelity, change `i += 2` to `i += 1` below.', '    for (int i = 1; i <= MAX_STEPS; i += 2) {', '        if (abs(float(i)) > maxOffset) { break; }', '        maxStepsReached += 1.0;', '        // Divide blurOffset by 2.0 so that motion blur starts half way behind itself', '        //   preventing blur from shoving samples in any direction', '        vec2 offset = (blurOffset / 2.0) - (blurOffset * (float(i) / maxOffset));', '        vec4 stepSample = textTexture(uv + (offset / uResolution.xy));',, '        result += stepSample;', '    }', '    if (maxOffset >= 1.0) {', '        result /= maxStepsReached;', '        //result.a = pow(result.a, 2.0); // Apply logarithmic smoothing to alpha', '        result.a -= (randNoise * (1.0 - result.a)); // Apply noise to smoothed alpha', '    }', '    return result;', '}', 'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {', '    // Setup', '    // -------------------------------', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    float offset = min(float(MAX_STEPS), uResolution.y * uOffset);', '    float slope = normalizedSlope(slopeForDegrees(uRotation), uResolution);', '    // We want the blur to be the full offset amount in each direction', '    //   and to adjust with our logarithmic adjustment made later, so multiply by 4', '    float adjustedOffset = offset;// * 4.0;', '    vec2 blurOffset = motionBlurOffsets(fragCoord, uRotation, adjustedOffset);', '    // Set Starting Points', '    // -------------------------------', '    vec2 rUv = uv;', '    vec2 gUv = uv;', '    vec2 bUv = uv;', '    vec2 k = offsetsForCoordAtDistanceOnSlope(offset, slope) / uResolution;', '    if (uRotation <= 90.0 || uRotation >= 270.0) {', '        rUv += k;', '        bUv -= k;', '    }', '    else {', '        rUv -= k;', '        bUv += k;', '    }', '    // Blur and Split Channels', '    // -------------------------------', '    vec4 resultR = vec4(0.0);', '    vec4 resultG = vec4(0.0);', '    vec4 resultB = vec4(0.0);', '    if (uApplyBlur > 0.0) {', '        resultR = motionBlur(rUv, blurOffset, adjustedOffset);', '        resultG = motionBlur(gUv, blurOffset, adjustedOffset);', '        resultB = motionBlur(bUv, blurOffset, adjustedOffset);', '    } else {', '        resultR = textTexture(rUv);', '        resultG = textTexture(gUv);', '        resultB = textTexture(bUv);', '    }', '    float a = resultR.a + resultG.a + resultB.a;', '    resultR = normalBlend(resultR, uBlendColor);', '    resultG = normalBlend(resultG, uBlendColor);', '    resultB = normalBlend(resultB, uBlendColor);', '    mainImage = vec4(resultR.r, resultG.g, resultB.b, a);', '}'].join('\\n');\n  var uniforms = {\n    uOffset: {\n      type: '1f',\n      value: 0.05\n    },\n    uRotation: {\n      type: '1f',\n      value: 45.0\n    },\n    uApplyBlur: {\n      type: '1f',\n      value: 1.0\n    },\n    uAnimateNoise: {\n      type: '1f',\n      value: 1.0\n    }\n  };\n  return {\n    shader: shader,\n    uniforms: uniforms\n  };\n};\n\nvar fliesMaterial = function fliesMaterial(BlotterInstance) {\n  var shader = [BlotterInstance.Assets.Shaders.Random, 'vec2 random2(vec2 p) {', '    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);', '}', 'float isParticle(out vec3 particleColor, vec2 fragCoord, float pointRadius, float pointCellWidth, float dodge, vec2 dodgePosition, float dodgeSpread, float speed) {    ', '    if (pointCellWidth == 0.0) { return 0.0; };', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    float pointRadiusOfCell = pointRadius / pointCellWidth;', '    vec2 totalCellCount = uResolution.xy / pointCellWidth;', '    vec2 cellUv = uv * totalCellCount;', '    // Tile the space', '    vec2 iUv = floor(cellUv);', '    vec2 fUv = fract(cellUv);', '    float minDist = 1.0;  // minimun distance', '    vec4 baseSample = textTexture(cellUv);', '    float maxWeight = 0.0;', '    particleColor = baseSample.rgb;', '    for (int y= -1; y <= 1; y++) {', '        for (int x= -1; x <= 1; x++) {', '            // Neighbor place in the grid', '            vec2 neighbor = vec2(float(x), float(y));', '            // Random position from current + neighbor place in the grid', '            vec2 point = random2(iUv + neighbor);', \"            // Get cell weighting from cell's center alpha\", '            vec2 cellRowCol = floor(fragCoord / pointCellWidth) + neighbor;', '            vec2 cellFragCoord = ((cellRowCol * pointCellWidth) + (pointCellWidth / 2.0));', '            vec4 cellSample = textTexture(cellFragCoord / uResolution.xy);', '            float cellWeight = cellSample.a;', '            if (cellWeight < 1.0) {', '               // If the cell is not fully within our text, we should disregard it', '               continue;', '            }', '            maxWeight = max(maxWeight, cellWeight);', '            if (cellWeight == maxWeight) {', '                particleColor = cellSample.rgb;', '            }', '            float distanceFromDodge = distance(dodgePosition * uResolution.xy, cellFragCoord) / uResolution.y;', '            distanceFromDodge = 1.0 - smoothstep(0.0, dodgeSpread, distanceFromDodge);', '            // Apply weighting to noise and dodge if dodge is set to 1.0', '            cellWeight = step(cellWeight, random(cellRowCol)) + (distanceFromDodge * dodge);', '            // Animate the point', '            point = 0.5 + 0.75 * sin((uGlobalTime * speed) + 6.2831 * point);', '            // Vector between the pixel and the point', '            vec2 diff = neighbor + point - fUv;', '            // Distance to the point', '            float dist = length(diff);', '            dist += cellWeight; // Effectively remove point', '            // Keep the closer distance', '            minDist = min(minDist, dist);', '        }', '    }', '    float pointEasing = pointRadiusOfCell - (1.0 / pointCellWidth);', '    float isParticle = 1.0 - smoothstep(pointEasing, pointRadiusOfCell, minDist);', '    return isParticle;', '}', 'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    // Convert uPointCellWidth to pixels, keeping it between 1 and the total y resolution of the text', '    // Note: floor uPointCellWidth here so that we dont have half pixel widths on retina displays', '    float pointCellWidth = floor(max(0.0, min(1.0, uPointCellWidth) * uResolution.y));', '    // Ensure uPointRadius allow points to exceed the width of their cells', '    float pointRadius = uPointRadius * 0.8;', '    pointRadius = min(pointRadius * pointCellWidth, pointCellWidth);', '    float dodge = ceil(uDodge);', '    vec3 outColor = vec3(0.0);', '    float point = isParticle(outColor, fragCoord, pointRadius, pointCellWidth, dodge, uDodgePosition, uDodgeSpread, uSpeed);', '    mainImage = vec4(outColor, point);', '}'].join('\\n');\n  var uniforms = {\n    uPointCellWidth: {\n      type: '1f',\n      value: 0.04\n    },\n    uPointRadius: {\n      type: '1f',\n      value: 0.75\n    },\n    uDodge: {\n      type: '1f',\n      value: 0.0\n    },\n    uDodgePosition: {\n      type: '2f',\n      value: [0.5, 0.5]\n    },\n    uDodgeSpread: {\n      type: '1f',\n      value: 0.25\n    },\n    uSpeed: {\n      type: '1f',\n      value: 1.0\n    }\n  };\n  return {\n    shader: shader,\n    uniforms: uniforms\n  };\n};\n\nvar liquidDistortionMaterial = function liquidDistortionMaterial(BlotterInstance) {\n  var shader = [BlotterInstance.Assets.Shaders.Noise3D, 'void mainImage( out vec4 mainImage, in vec2 fragCoord )', '{', '    // Setup ========================================================================', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    float z = uSeed + uGlobalTime * uSpeed;', '    uv += snoise(vec3(uv, z)) * uVolatility;', '    mainImage = textTexture(uv);', '}'].join('\\n');\n  var uniforms = {\n    uSpeed: {\n      type: '1f',\n      value: 1.0\n    },\n    uVolatility: {\n      type: '1f',\n      value: 0.15\n    },\n    uSeed: {\n      type: '1f',\n      value: 0.1\n    }\n  };\n  return {\n    shader: shader,\n    uniforms: uniforms\n  };\n};\n\nvar distortionText = function distortionText(BlotterInstance) {\n  var shader = [BlotterInstance.Assets.Shaders.PI, BlotterInstance.Assets.Shaders.LineMath, BlotterInstance.Assets.Shaders.Noise, '// Fix a floating point number to two decimal places', 'float toFixedTwo(float f) {', '    return float(int(f * 100.0)) / 100.0;', '}', '// Via: http://www.iquilezles.org/www/articles/functions/functions.htm', 'float impulse(float k, float x) {', '    float h = k * x;', '    return h * exp(1.0 - h);', '}', 'vec2 waveOffset(vec2 fragCoord, float sineDistortSpread, float sineDistortCycleCount, float sineDistortAmplitude, float noiseDistortVolatility, float noiseDistortAmplitude, vec2 distortPosition, float deg, float speed) {', '    // Setup', '    // -------------------------------', '    deg = toFixedTwo(deg);', '    float centerDistance = 0.5;', '    vec2 centerUv = vec2(centerDistance);', '    vec2 centerCoord = uResolution.xy * centerUv;', '    float changeOverTime = uGlobalTime * speed;', '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);', '    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0', '    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg), uResolution.xy);', '    // Find intersects for line with edges of viewport', '    // -------------------------------', '    vec2 edgeIntersectA = vec2(0.0);', '    vec2 edgeIntersectB = vec2(0.0);', '    intersectsOnRectForLine(edgeIntersectA, edgeIntersectB, vec2(0.0), uResolution.xy, centerCoord, slope);', '    float crossSectionLength = distance(edgeIntersectA, edgeIntersectB);', '    // Find the threshold for degrees at which our intersectsOnRectForLine function would flip', '    //   intersects A and B because of the order in which it finds them. This is the angle at which', '    //   the y coordinate for the hypotenuse of a right triangle whose oposite adjacent edge runs from', '    //   vec2(0.0, centerCoord.y) to centerCoord and whose opposite edge runs from vec2(0.0, centerCoord.y) to', '    //   vec2(0.0, uResolution.y) exceeeds uResolution.y', '    float thresholdDegA = atan(centerCoord.y / centerCoord.x) * (180.0 / PI);', '    float thresholdDegB = mod(thresholdDegA + 180.0, 360.0);', '    vec2 edgeIntersect = vec2(0.0);', '    if (deg < thresholdDegA || deg > thresholdDegB) {', '        edgeIntersect = edgeIntersectA;', '    } else {', '        edgeIntersect = edgeIntersectB;', '    }', '    vec2 perpendicularIntersectA = vec2(0.0);', '    vec2 perpendicularIntersectB = vec2(0.0);', '    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), uResolution.xy, centerCoord, perpendicularSlope); ', '    float perpendicularLength = distance(perpendicularIntersectA, perpendicularIntersectA);', '    vec2 coordLineIntersect = vec2(0.0);', '    lineLineIntersection(coordLineIntersect, centerCoord, slope, fragCoord, perpendicularSlope);', '    // Define placement for distortion ', '    // -------------------------------', '    vec2 distortPositionIntersect = vec2(0.0);', '    lineLineIntersection(distortPositionIntersect, distortPosition * uResolution.xy, perpendicularSlope, edgeIntersect, slope);', '    float distortDistanceFromEdge = (distance(edgeIntersect, distortPositionIntersect) / crossSectionLength);// + sineDistortSpread;', '    float uvDistanceFromDistort = distance(edgeIntersect, coordLineIntersect) / crossSectionLength;', '    float noiseDistortVarianceAdjuster = uvDistanceFromDistort + changeOverTime;', '    uvDistanceFromDistort += -centerDistance + distortDistanceFromEdge + changeOverTime;', '    uvDistanceFromDistort = mod(uvDistanceFromDistort, 1.0); // For sine, keep distance between 0.0 and 1.0', '    // Define sine distortion ', '    // -------------------------------', '    float minThreshold = centerDistance - sineDistortSpread;', '    float maxThreshold = centerDistance + sineDistortSpread;', '    uvDistanceFromDistort = clamp(((uvDistanceFromDistort - minThreshold)/(maxThreshold - minThreshold)), 0.0, 1.0);', '    if (sineDistortSpread < 0.5) {', '        // Add smoother decay to sin distort when it isnt taking up the full viewport.', '        uvDistanceFromDistort = impulse(uvDistanceFromDistort, uvDistanceFromDistort);', '    }', '    float sineDistortion = sin(uvDistanceFromDistort * PI * sineDistortCycleCount) * sineDistortAmplitude;', '    // Define noise distortion ', '    // -------------------------------', '    float noiseDistortion = noise(noiseDistortVolatility * noiseDistortVarianceAdjuster) * noiseDistortAmplitude;', '    if (noiseDistortVolatility > 0.0) {', '        noiseDistortion -= noiseDistortAmplitude / 2.0; // Adjust primary distort so that it distorts in two directions.', '    }', '    noiseDistortion *= (sineDistortion > 0.0 ? 1.0 : -1.0); // Adjust primary distort to account for sin variance.', '    // Combine distortions to find UV offsets ', '    // -------------------------------', '    vec2 kV = offsetsForCoordAtDistanceOnSlope(sineDistortion + noiseDistortion, perpendicularSlope);', '    if (deg <= 0.0 || deg >= 180.0) {', '        kV *= -1.0;', '    }', '    return kV;', '}', 'void mainImage( out vec4 mainImage, in vec2 fragCoord )', '{', '    // Setup', '    // -------------------------------', '    vec2 uv = fragCoord.xy / uResolution.xy;', '    // Minor hacks to ensure our waves start horizontal and animating in a downward direction by default.', '    uRotation = mod(uRotation + 270.0, 360.0);', '    uDistortPosition.y = 1.0 - uDistortPosition.y;', '    // Distortion', '    // -------------------------------', '    vec2 offset = waveOffset(fragCoord, uSineDistortSpread, uSineDistortCycleCount, uSineDistortAmplitude, uNoiseDistortVolatility, uNoiseDistortAmplitude, uDistortPosition, uRotation, uSpeed);', '    mainImage = textTexture(uv + offset);', '}'].join('\\n');\n  var uniforms = {\n    uSineDistortSpread: {\n      type: '1f',\n      value: 0.05\n    },\n    uSineDistortCycleCount: {\n      type: '1f',\n      value: 2.0\n    },\n    uSineDistortAmplitude: {\n      type: '1f',\n      value: 0.25\n    },\n    uNoiseDistortVolatility: {\n      type: '1f',\n      value: 20.0\n    },\n    uNoiseDistortAmplitude: {\n      type: '1f',\n      value: 0.01\n    },\n    uDistortPosition: {\n      type: '2f',\n      value: [0.5, 0.5]\n    },\n    uRotation: {\n      type: '1f',\n      value: 170.0\n    },\n    uSpeed: {\n      type: '1f',\n      value: 0.08\n    }\n  };\n  return {\n    shader: shader,\n    uniforms: uniforms\n  };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar hasBlotterInstance = function hasBlotterInstance() {\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) !== undefined && window.Blotter === undefined) {\n    throw Error(\"\\n              Couldn't find a Blotter.js script. Place this script in your HTML file to instantiate Blotter module and WebGL context.\\n          \");\n  }\n}; // A high order component that creates a blotter text component using the input parameters\n\n\nvar createBlotterComponent = function createBlotterComponent(_ref) {\n  var material = _ref.material,\n      setMaterialValues = _ref.setMaterialValues,\n      defaultProps = _ref.defaultProps,\n      displayName = _ref.displayName;\n\n  var BlotterComponent = function (_React$Component) {\n    inherits(BlotterComponent, _React$Component);\n\n    function BlotterComponent() {\n      var _ref2;\n\n      var _temp, _this, _ret;\n\n      classCallCheck(this, BlotterComponent);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = BlotterComponent.__proto__ || Object.getPrototypeOf(BlotterComponent)).call.apply(_ref2, [this].concat(args))), _this), _this.material = null, _this.appendText = function (textObj, id) {\n        var element = document.getElementById(id);\n\n        if (element) {\n          textObj.appendTo(element);\n        } else {\n          console.error('Couldn\\'t find an element with id \\'' + id + '\\'.');\n        }\n      }, _temp), possibleConstructorReturn(_this, _ret);\n    }\n\n    createClass(BlotterComponent, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        // Check if the blotter instance is initiated otherwise throw an error\n        hasBlotterInstance(); // TODO: Publish a private fork of Blotter with customised build setup\n\n        var BlotterInstance = window.Blotter; // Each material function returns an object which includes a shader string and uniforms to update the effects in shader\n\n        var _material = material(BlotterInstance),\n            shader = _material.shader,\n            uniforms = _material.uniforms;\n\n        this.material = new BlotterInstance.ShaderMaterial(shader, {\n          uniforms: uniforms\n        }); // Create a text object with style properties\n\n        var text = new BlotterInstance.Text(this.props.text, {\n          family: this.props.fontFamily,\n          size: this.props.fontSize,\n          fill: this.props.fill,\n          paddingLeft: this.props.paddingLeft,\n          paddingRight: this.props.paddingRight,\n          paddingBottom: this.props.paddingBottom,\n          paddingTop: this.props.paddingTop,\n          leading: this.props.lineHeight,\n          weight: this.props.fontWeight,\n          style: this.props.fontStyle\n        });\n        var blotter = new Blotter(this.material, {\n          texts: text\n        });\n        var textObj = blotter.forText(text); // Append the text canvas to a user defined element id or wrapper id\n\n        this.props.appendTo && typeof this.props.appendTo === 'string' ? this.appendText(textObj, this.props.appendTo) : this.appendText(textObj, this.props.id); // Invoke the prop callback with rendering context. Useful if you want to update the canvas with other third party libs.\n\n        this.props.get2dContext && typeof this.props.get2dContext === 'function' ? this.props.get2dContext(textObj.context) : null; // On first mount, set the material values (this is optional)\n\n        setMaterialValues(this.material, this.props);\n      }\n    }, {\n      key: 'componentDidUpdate',\n      value: function componentDidUpdate() {\n        // Update the shader material with new values (or uniforms)\n        setMaterialValues(this.material, this.props);\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        if (this.props.appendTo) return null;\n        return React.createElement('div', {\n          id: this.props.id,\n          style: this.props.wrapperStyles\n        });\n      }\n    }]);\n    return BlotterComponent;\n  }(React.Component);\n\n  BlotterComponent.displayName = displayName;\n  BlotterComponent.defaultProps = defaultProps;\n  return BlotterComponent;\n};\n\nvar SplitColorChannelText = createBlotterComponent({\n  material: channelSplitMaterial,\n  defaultProps: {\n    id: 'channel-split-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    rotation: 0.0,\n    rgbOffset: 0.05,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5\n  },\n  displayName: 'SplitColorChannel',\n  setMaterialValues: function setMaterialValues(material, props) {\n    material.uniforms.uOffset.value = parseFloat(props.rgbOffset);\n    material.uniforms.uRotation.value = parseFloat(props.rotation);\n    material.uniforms.uApplyBlur.value = props.addBlur ? 1.0 : 0.0;\n    material.uniforms.uAnimateNoise.value = props.addNoise ? 1.0 : 0.0;\n  }\n});\nvar FliesText = createBlotterComponent({\n  material: fliesMaterial,\n  defaultProps: {\n    cellWidth: 0.04,\n    cellRadius: 0.5,\n    speed: 2.0,\n    dodge: false,\n    dodgeX: 0.5,\n    dodgeY: 0.8,\n    dodgeSpread: 0.75,\n    id: 'flies-text-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5\n  },\n  displayName: 'FliesText',\n  setMaterialValues: function setMaterialValues(material, props) {\n    material.uniforms.uPointCellWidth.value = parseFloat(props.cellWidth);\n    material.uniforms.uPointRadius.value = parseFloat(props.cellRadius);\n    material.uniforms.uSpeed.value = parseFloat(props.speed);\n    material.uniforms.uDodge.value = props.dodge ? 1.0 : 0.0;\n    material.uniforms.uDodgePosition.value = [parseFloat(props.dodgeX), parseFloat(props.dodgeY)];\n    material.uniforms.uDodgeSpread.value = parseFloat(props.dodgeSpread);\n  }\n});\nvar LiquidDistortionText = createBlotterComponent({\n  defaultProps: {\n    id: 'liquid-distortion-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5,\n    speed: 1.5,\n    volatility: 0.04\n  },\n  displayName: 'LiquidDistortionText',\n  setMaterialValues: function setMaterialValues(material, props) {\n    material.uniforms.uSpeed.value = parseFloat(props.speed);\n    material.uniforms.uVolatility.value = parseFloat(props.volatility);\n  },\n  material: liquidDistortionMaterial\n});\n\nvar _defaultProps;\n\nvar DistortionText = createBlotterComponent({\n  material: distortionText,\n  defaultProps: (_defaultProps = {\n    id: 'distortion-text-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    rotation: 0.0,\n    rgbOffset: 0.05,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    speed: 0.084\n  }, defineProperty(_defaultProps, 'rotation', 120.0), defineProperty(_defaultProps, 'distortX', 0.06), defineProperty(_defaultProps, 'distortY', 0.09), defineProperty(_defaultProps, 'noiseAmplitude', 0.101), defineProperty(_defaultProps, 'noiseVolatility', 8), _defaultProps),\n  setMaterialValues: function setMaterialValues(material, props) {\n    material.uniforms.uNoiseDistortVolatility.value = props.noiseVolatility;\n    material.uniforms.uNoiseDistortAmplitude.value = props.noiseAmplitude;\n    material.uniforms.uDistortPosition.value = [props.distortX, props.distortY];\n    material.uniforms.uRotation.value = props.rotation;\n    material.uniforms.uSpeed.value = props.speed;\n    material.uniforms.uSineDistortSpread.value = 0;\n    material.uniforms.uSineDistortCycleCount.value = 0;\n    material.uniforms.uSineDistortAmplitude.value = 0;\n  },\n  displayName: 'DistortionText'\n});\nexport { SplitColorChannelText, FliesText, LiquidDistortionText, DistortionText };","map":{"version":3,"sources":["../src/materials.js","../src/hasBlotterInstance.js","../src/createBlotterComponent.js","../src/SpitColorChannelText.js","../src/FliesText.js","../src/LiquidDistortionText.js","../src/DistortionText.js"],"names":["channelSplitMaterial","shader","BlotterInstance","uniforms","type","value","fliesMaterial","liquidDistortionMaterial","distortionText","hasBlotterInstance","window","Error","createBlotterComponent","material","setMaterialValues","defaultProps","displayName","BlotterComponent","React","text","fontStyle","blotter","textObj","element","document","SplitColorChannelText","parseFloat","props","FliesText","LiquidDistortionText","DistortionText"],"mappings":"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","sourcesContent":["// The shaders are copied from https://github.com/bradley/Blotter/tree/master/build/materials.\n// Since otherwise we need to have material scripts separately in HTML file, now each component can import\n// these materials and update the shader.\n\nexport const channelSplitMaterial = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.PI,\n    BlotterInstance.Assets.Shaders.LineMath,\n    BlotterInstance.Assets.Shaders.Random,\n\n    'const int MAX_STEPS = 200;',\n\n    '// Fix a floating point number to two decimal places',\n    'float toFixedTwo(float f) {',\n    '    return float(int(f * 100.0)) / 100.0;',\n    '}',\n\n    'vec2 motionBlurOffsets(vec2 fragCoord, float deg, float spread) {',\n\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    vec2 centerUv = vec2(0.5);',\n    '    vec2 centerCoord = uResolution.xy * centerUv;',\n\n    '    deg = toFixedTwo(deg);',\n    '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);',\n\n    '    // Find offsets',\n    '    // -------------------------------',\n\n    '    vec2 k = offsetsForCoordAtDistanceOnSlope(spread, slope);',\n    '    if (deg <= 90.0 || deg >= 270.0) {',\n    '        k *= -1.0;',\n    '    }',\n\n    '    return k;',\n    '}',\n\n    'float noiseWithWidthAtUv(float width, vec2 uv) {',\n    '    float noiseModifier = 1.0;',\n    '    if (uAnimateNoise > 0.0) {',\n    '        noiseModifier = sin(uGlobalTime);',\n    '    }',\n\n    '    vec2 noiseRowCol = floor((uv * uResolution.xy) / width);',\n    '    vec2 noiseFragCoord = ((noiseRowCol * width) + (width / 2.0));',\n    '    vec2 noiseUv = noiseFragCoord / uResolution.xy;',\n\n    '    return random(noiseUv * noiseModifier) * 0.125;',\n    '}',\n\n    'vec4 motionBlur(vec2 uv, vec2 blurOffset, float maxOffset) {',\n    '    float noiseWidth = 3.0;',\n    '    float randNoise = noiseWithWidthAtUv(noiseWidth, uv);',\n\n    '    vec4 result = textTexture(uv);',\n\n    '    float maxStepsReached = 0.0;',\n\n    '    // Note: Step by 2 to optimize performance. We conceal lossiness here via applied noise.',\n    '    //   If you do want maximum fidelity, change `i += 2` to `i += 1` below.',\n    '    for (int i = 1; i <= MAX_STEPS; i += 2) {',\n    '        if (abs(float(i)) > maxOffset) { break; }',\n    '        maxStepsReached += 1.0;',\n\n    '        // Divide blurOffset by 2.0 so that motion blur starts half way behind itself',\n    '        //   preventing blur from shoving samples in any direction',\n    '        vec2 offset = (blurOffset / 2.0) - (blurOffset * (float(i) / maxOffset));',\n    '        vec4 stepSample = textTexture(uv + (offset / uResolution.xy));',\n\n    ,\n    '        result += stepSample;',\n    '    }',\n\n    '    if (maxOffset >= 1.0) {',\n    '        result /= maxStepsReached;',\n    '        //result.a = pow(result.a, 2.0); // Apply logarithmic smoothing to alpha',\n    '        result.a -= (randNoise * (1.0 - result.a)); // Apply noise to smoothed alpha',\n    '    }',\n\n    '    return result;',\n    '}',\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {',\n\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    float offset = min(float(MAX_STEPS), uResolution.y * uOffset);',\n\n    '    float slope = normalizedSlope(slopeForDegrees(uRotation), uResolution);',\n\n    '    // We want the blur to be the full offset amount in each direction',\n    '    //   and to adjust with our logarithmic adjustment made later, so multiply by 4',\n    '    float adjustedOffset = offset;// * 4.0;',\n\n    '    vec2 blurOffset = motionBlurOffsets(fragCoord, uRotation, adjustedOffset);',\n\n    '    // Set Starting Points',\n    '    // -------------------------------',\n\n    '    vec2 rUv = uv;',\n    '    vec2 gUv = uv;',\n    '    vec2 bUv = uv;',\n\n    '    vec2 k = offsetsForCoordAtDistanceOnSlope(offset, slope) / uResolution;',\n\n    '    if (uRotation <= 90.0 || uRotation >= 270.0) {',\n    '        rUv += k;',\n    '        bUv -= k;',\n    '    }',\n    '    else {',\n    '        rUv -= k;',\n    '        bUv += k;',\n    '    }',\n\n    '    // Blur and Split Channels',\n    '    // -------------------------------',\n\n    '    vec4 resultR = vec4(0.0);',\n    '    vec4 resultG = vec4(0.0);',\n    '    vec4 resultB = vec4(0.0);',\n\n    '    if (uApplyBlur > 0.0) {',\n    '        resultR = motionBlur(rUv, blurOffset, adjustedOffset);',\n    '        resultG = motionBlur(gUv, blurOffset, adjustedOffset);',\n    '        resultB = motionBlur(bUv, blurOffset, adjustedOffset);',\n    '    } else {',\n    '        resultR = textTexture(rUv);',\n    '        resultG = textTexture(gUv);',\n    '        resultB = textTexture(bUv);',\n    '    }',\n\n    '    float a = resultR.a + resultG.a + resultB.a;',\n\n    '    resultR = normalBlend(resultR, uBlendColor);',\n    '    resultG = normalBlend(resultG, uBlendColor);',\n    '    resultB = normalBlend(resultB, uBlendColor);',\n\n    '    mainImage = vec4(resultR.r, resultG.g, resultB.b, a);',\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uOffset: { type: '1f', value: 0.05 },\n    uRotation: { type: '1f', value: 45.0 },\n    uApplyBlur: { type: '1f', value: 1.0 },\n    uAnimateNoise: { type: '1f', value: 1.0 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n\nexport const fliesMaterial = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.Random,\n\n    'vec2 random2(vec2 p) {',\n    '    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);',\n    '}',\n\n    'float isParticle(out vec3 particleColor, vec2 fragCoord, float pointRadius, float pointCellWidth, float dodge, vec2 dodgePosition, float dodgeSpread, float speed) {    ',\n    '    if (pointCellWidth == 0.0) { return 0.0; };',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    float pointRadiusOfCell = pointRadius / pointCellWidth;',\n\n    '    vec2 totalCellCount = uResolution.xy / pointCellWidth;',\n    '    vec2 cellUv = uv * totalCellCount;',\n\n    '    // Tile the space',\n    '    vec2 iUv = floor(cellUv);',\n    '    vec2 fUv = fract(cellUv);',\n\n    '    float minDist = 1.0;  // minimun distance',\n\n    '    vec4 baseSample = textTexture(cellUv);',\n    '    float maxWeight = 0.0;',\n    '    particleColor = baseSample.rgb;',\n\n    '    for (int y= -1; y <= 1; y++) {',\n    '        for (int x= -1; x <= 1; x++) {',\n    '            // Neighbor place in the grid',\n    '            vec2 neighbor = vec2(float(x), float(y));',\n\n    '            // Random position from current + neighbor place in the grid',\n    '            vec2 point = random2(iUv + neighbor);',\n\n    \"            // Get cell weighting from cell's center alpha\",\n    '            vec2 cellRowCol = floor(fragCoord / pointCellWidth) + neighbor;',\n    '            vec2 cellFragCoord = ((cellRowCol * pointCellWidth) + (pointCellWidth / 2.0));',\n    '            vec4 cellSample = textTexture(cellFragCoord / uResolution.xy);',\n    '            float cellWeight = cellSample.a;',\n\n    '            if (cellWeight < 1.0) {',\n    '               // If the cell is not fully within our text, we should disregard it',\n    '               continue;',\n    '            }',\n\n    '            maxWeight = max(maxWeight, cellWeight);',\n    '            if (cellWeight == maxWeight) {',\n    '                particleColor = cellSample.rgb;',\n    '            }',\n\n    '            float distanceFromDodge = distance(dodgePosition * uResolution.xy, cellFragCoord) / uResolution.y;',\n    '            distanceFromDodge = 1.0 - smoothstep(0.0, dodgeSpread, distanceFromDodge);',\n\n    '            // Apply weighting to noise and dodge if dodge is set to 1.0',\n    '            cellWeight = step(cellWeight, random(cellRowCol)) + (distanceFromDodge * dodge);',\n\n    '            // Animate the point',\n    '            point = 0.5 + 0.75 * sin((uGlobalTime * speed) + 6.2831 * point);',\n\n    '            // Vector between the pixel and the point',\n    '            vec2 diff = neighbor + point - fUv;',\n\n    '            // Distance to the point',\n    '            float dist = length(diff);',\n    '            dist += cellWeight; // Effectively remove point',\n\n    '            // Keep the closer distance',\n    '            minDist = min(minDist, dist);',\n    '        }',\n    '    }',\n\n    '    float pointEasing = pointRadiusOfCell - (1.0 / pointCellWidth);',\n\n    '    float isParticle = 1.0 - smoothstep(pointEasing, pointRadiusOfCell, minDist);',\n\n    '    return isParticle;',\n    '}',\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord ) {',\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    // Convert uPointCellWidth to pixels, keeping it between 1 and the total y resolution of the text',\n    '    // Note: floor uPointCellWidth here so that we dont have half pixel widths on retina displays',\n    '    float pointCellWidth = floor(max(0.0, min(1.0, uPointCellWidth) * uResolution.y));',\n\n    '    // Ensure uPointRadius allow points to exceed the width of their cells',\n    '    float pointRadius = uPointRadius * 0.8;',\n    '    pointRadius = min(pointRadius * pointCellWidth, pointCellWidth);',\n\n    '    float dodge = ceil(uDodge);',\n\n    '    vec3 outColor = vec3(0.0);',\n    '    float point = isParticle(outColor, fragCoord, pointRadius, pointCellWidth, dodge, uDodgePosition, uDodgeSpread, uSpeed);',\n\n    '    mainImage = vec4(outColor, point);',\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uPointCellWidth: { type: '1f', value: 0.04 },\n    uPointRadius: { type: '1f', value: 0.75 },\n    uDodge: { type: '1f', value: 0.0 },\n    uDodgePosition: { type: '2f', value: [0.5, 0.5] },\n    uDodgeSpread: { type: '1f', value: 0.25 },\n    uSpeed: { type: '1f', value: 1.0 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n\nexport const liquidDistortionMaterial = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.Noise3D,\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord )',\n    '{',\n    '    // Setup ========================================================================',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n    '    float z = uSeed + uGlobalTime * uSpeed;',\n\n    '    uv += snoise(vec3(uv, z)) * uVolatility;',\n\n    '    mainImage = textTexture(uv);',\n\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uSpeed: { type: '1f', value: 1.0 },\n    uVolatility: { type: '1f', value: 0.15 },\n    uSeed: { type: '1f', value: 0.1 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n\nexport const distortionText = BlotterInstance => {\n  const shader = [\n    BlotterInstance.Assets.Shaders.PI,\n    BlotterInstance.Assets.Shaders.LineMath,\n    BlotterInstance.Assets.Shaders.Noise,\n\n    '// Fix a floating point number to two decimal places',\n    'float toFixedTwo(float f) {',\n    '    return float(int(f * 100.0)) / 100.0;',\n    '}',\n\n    '// Via: http://www.iquilezles.org/www/articles/functions/functions.htm',\n    'float impulse(float k, float x) {',\n    '    float h = k * x;',\n    '    return h * exp(1.0 - h);',\n    '}',\n\n    'vec2 waveOffset(vec2 fragCoord, float sineDistortSpread, float sineDistortCycleCount, float sineDistortAmplitude, float noiseDistortVolatility, float noiseDistortAmplitude, vec2 distortPosition, float deg, float speed) {',\n\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    deg = toFixedTwo(deg);',\n\n    '    float centerDistance = 0.5;',\n    '    vec2 centerUv = vec2(centerDistance);',\n    '    vec2 centerCoord = uResolution.xy * centerUv;',\n\n    '    float changeOverTime = uGlobalTime * speed;',\n\n    '    float slope = normalizedSlope(slopeForDegrees(deg), uResolution.xy);',\n    '    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0',\n    '    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg), uResolution.xy);',\n\n    '    // Find intersects for line with edges of viewport',\n    '    // -------------------------------',\n\n    '    vec2 edgeIntersectA = vec2(0.0);',\n    '    vec2 edgeIntersectB = vec2(0.0);',\n    '    intersectsOnRectForLine(edgeIntersectA, edgeIntersectB, vec2(0.0), uResolution.xy, centerCoord, slope);',\n    '    float crossSectionLength = distance(edgeIntersectA, edgeIntersectB);',\n\n    '    // Find the threshold for degrees at which our intersectsOnRectForLine function would flip',\n    '    //   intersects A and B because of the order in which it finds them. This is the angle at which',\n    '    //   the y coordinate for the hypotenuse of a right triangle whose oposite adjacent edge runs from',\n    '    //   vec2(0.0, centerCoord.y) to centerCoord and whose opposite edge runs from vec2(0.0, centerCoord.y) to',\n    '    //   vec2(0.0, uResolution.y) exceeeds uResolution.y',\n    '    float thresholdDegA = atan(centerCoord.y / centerCoord.x) * (180.0 / PI);',\n    '    float thresholdDegB = mod(thresholdDegA + 180.0, 360.0);',\n\n    '    vec2 edgeIntersect = vec2(0.0);',\n    '    if (deg < thresholdDegA || deg > thresholdDegB) {',\n    '        edgeIntersect = edgeIntersectA;',\n    '    } else {',\n    '        edgeIntersect = edgeIntersectB;',\n    '    }',\n\n    '    vec2 perpendicularIntersectA = vec2(0.0);',\n    '    vec2 perpendicularIntersectB = vec2(0.0);',\n    '    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), uResolution.xy, centerCoord, perpendicularSlope); ',\n    '    float perpendicularLength = distance(perpendicularIntersectA, perpendicularIntersectA);',\n\n    '    vec2 coordLineIntersect = vec2(0.0);',\n    '    lineLineIntersection(coordLineIntersect, centerCoord, slope, fragCoord, perpendicularSlope);',\n\n    '    // Define placement for distortion ',\n    '    // -------------------------------',\n\n    '    vec2 distortPositionIntersect = vec2(0.0);',\n    '    lineLineIntersection(distortPositionIntersect, distortPosition * uResolution.xy, perpendicularSlope, edgeIntersect, slope);',\n    '    float distortDistanceFromEdge = (distance(edgeIntersect, distortPositionIntersect) / crossSectionLength);// + sineDistortSpread;',\n\n    '    float uvDistanceFromDistort = distance(edgeIntersect, coordLineIntersect) / crossSectionLength;',\n    '    float noiseDistortVarianceAdjuster = uvDistanceFromDistort + changeOverTime;',\n    '    uvDistanceFromDistort += -centerDistance + distortDistanceFromEdge + changeOverTime;',\n    '    uvDistanceFromDistort = mod(uvDistanceFromDistort, 1.0); // For sine, keep distance between 0.0 and 1.0',\n\n    '    // Define sine distortion ',\n    '    // -------------------------------',\n\n    '    float minThreshold = centerDistance - sineDistortSpread;',\n    '    float maxThreshold = centerDistance + sineDistortSpread;',\n\n    '    uvDistanceFromDistort = clamp(((uvDistanceFromDistort - minThreshold)/(maxThreshold - minThreshold)), 0.0, 1.0);',\n    '    if (sineDistortSpread < 0.5) {',\n    '        // Add smoother decay to sin distort when it isnt taking up the full viewport.',\n    '        uvDistanceFromDistort = impulse(uvDistanceFromDistort, uvDistanceFromDistort);',\n    '    }',\n\n    '    float sineDistortion = sin(uvDistanceFromDistort * PI * sineDistortCycleCount) * sineDistortAmplitude;',\n\n    '    // Define noise distortion ',\n    '    // -------------------------------',\n\n    '    float noiseDistortion = noise(noiseDistortVolatility * noiseDistortVarianceAdjuster) * noiseDistortAmplitude;',\n    '    if (noiseDistortVolatility > 0.0) {',\n    '        noiseDistortion -= noiseDistortAmplitude / 2.0; // Adjust primary distort so that it distorts in two directions.',\n    '    }',\n    '    noiseDistortion *= (sineDistortion > 0.0 ? 1.0 : -1.0); // Adjust primary distort to account for sin variance.',\n\n    '    // Combine distortions to find UV offsets ',\n    '    // -------------------------------',\n\n    '    vec2 kV = offsetsForCoordAtDistanceOnSlope(sineDistortion + noiseDistortion, perpendicularSlope);',\n    '    if (deg <= 0.0 || deg >= 180.0) {',\n    '        kV *= -1.0;',\n    '    }',\n\n    '    return kV;',\n    '}',\n\n    'void mainImage( out vec4 mainImage, in vec2 fragCoord )',\n    '{',\n    '    // Setup',\n    '    // -------------------------------',\n\n    '    vec2 uv = fragCoord.xy / uResolution.xy;',\n\n    '    // Minor hacks to ensure our waves start horizontal and animating in a downward direction by default.',\n    '    uRotation = mod(uRotation + 270.0, 360.0);',\n    '    uDistortPosition.y = 1.0 - uDistortPosition.y;',\n\n    '    // Distortion',\n    '    // -------------------------------',\n\n    '    vec2 offset = waveOffset(fragCoord, uSineDistortSpread, uSineDistortCycleCount, uSineDistortAmplitude, uNoiseDistortVolatility, uNoiseDistortAmplitude, uDistortPosition, uRotation, uSpeed);',\n\n    '    mainImage = textTexture(uv + offset);',\n    '}'\n  ].join('\\n');\n\n  const uniforms = {\n    uSineDistortSpread: { type: '1f', value: 0.05 },\n    uSineDistortCycleCount: { type: '1f', value: 2.0 },\n    uSineDistortAmplitude: { type: '1f', value: 0.25 },\n    uNoiseDistortVolatility: { type: '1f', value: 20.0 },\n    uNoiseDistortAmplitude: { type: '1f', value: 0.01 },\n    uDistortPosition: { type: '2f', value: [0.5, 0.5] },\n    uRotation: { type: '1f', value: 170.0 },\n    uSpeed: { type: '1f', value: 0.08 }\n  };\n\n  return {\n    shader,\n    uniforms\n  };\n};\n","export const hasBlotterInstance = () => {\n  if (typeof window !== undefined && window.Blotter === undefined) {\n    throw Error(`\n              Couldn't find a Blotter.js script. Place this script in your HTML file to instantiate Blotter module and WebGL context.\n          `);\n  }\n};\n","import React from 'react'\nimport { hasBlotterInstance } from './hasBlotterInstance'\n\n// A high order component that creates a blotter text component using the input parameters\nexport const createBlotterComponent = ({\n\t// A material is a function that returns a shader string and uniforms to update the effects\n\tmaterial,\n\t// setMaterialValues is a function that takes a shader material and input props, and updates the materials with those props\n\t// This is invoked on first mount and subsequent state updates\n\tsetMaterialValues,\n\t// Default props of the component\n\tdefaultProps,\n\t// Component's display name (useful for debugging)\n\tdisplayName,\n}) => {\n\tclass BlotterComponent extends React.Component {\n\t\tmaterial = null\n\n\t\tstatic displayName = displayName\n\n\t\tstatic defaultProps = defaultProps\n\n\t\tcomponentDidMount() {\n\t\t\t// Check if the blotter instance is initiated otherwise throw an error\n\t\t\thasBlotterInstance()\n\n\t\t\t// TODO: Publish a private fork of Blotter with customised build setup\n\t\t\tconst BlotterInstance = window.Blotter\n\n\t\t\t// Each material function returns an object which includes a shader string and uniforms to update the effects in shader\n\t\t\tconst { shader, uniforms } = material(BlotterInstance)\n\n\t\t\tthis.material = new BlotterInstance.ShaderMaterial(shader, {\n\t\t\t\tuniforms,\n\t\t\t})\n\n\t\t\t// Create a text object with style properties\n\t\t\tconst text = new BlotterInstance.Text(this.props.text, {\n\t\t\t\tfamily: this.props.fontFamily,\n\t\t\t\tsize: this.props.fontSize,\n\t\t\t\tfill: this.props.fill,\n\t\t\t\tpaddingLeft: this.props.paddingLeft,\n\t\t\t\tpaddingRight: this.props.paddingRight,\n\t\t\t\tpaddingBottom: this.props.paddingBottom,\n\t\t\t\tpaddingTop: this.props.paddingTop,\n\t\t\t\tleading: this.props.lineHeight,\n\t\t\t\tweight: this.props.fontWeight,\n\t\t\t\tstyle: this.props.fontStyle,\n\t\t\t})\n\n\t\t\tconst blotter = new Blotter(this.material, {\n\t\t\t\ttexts: text,\n\t\t\t})\n\n\t\t\tconst textObj = blotter.forText(text)\n\n\t\t\t// Append the text canvas to a user defined element id or wrapper id\n\t\t\tthis.props.appendTo && typeof this.props.appendTo === 'string'\n\t\t\t\t? this.appendText(textObj, this.props.appendTo)\n\t\t\t\t: this.appendText(textObj, this.props.id)\n\n\t\t\t// Invoke the prop callback with rendering context. Useful if you want to update the canvas with other third party libs.\n\t\t\tthis.props.get2dContext && typeof this.props.get2dContext === 'function'\n\t\t\t\t? this.props.get2dContext(textObj.context)\n\t\t\t\t: null\n\n\t\t\t// On first mount, set the material values (this is optional)\n\t\t\tsetMaterialValues(this.material, this.props)\n\t\t}\n\n\t\tcomponentDidUpdate() {\n\t\t\t// Update the shader material with new values (or uniforms)\n\t\t\tsetMaterialValues(this.material, this.props)\n\t\t}\n\n\t\tappendText = (textObj, id) => {\n\t\t\tconst element = document.getElementById(id)\n\n\t\t\tif (element) {\n\t\t\t\ttextObj.appendTo(element)\n\t\t\t} else {\n\t\t\t\tconsole.error(`Couldn't find an element with id '${id}'.`)\n\t\t\t}\n\t\t}\n\n\t\trender() {\n\t\t\tif (this.props.appendTo) return null\n\n\t\t\treturn <div id={this.props.id} style={this.props.wrapperStyles} />\n\t\t}\n\t}\n\n\treturn BlotterComponent\n}\n","import { channelSplitMaterial } from './materials';\n\nimport { createBlotterComponent } from './createBlotterComponent';\n\nexport const SplitColorChannelText = createBlotterComponent({\n  material: channelSplitMaterial,\n  defaultProps: {\n    id: 'channel-split-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    rotation: 0.0,\n    rgbOffset: 0.05,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5\n  },\n  displayName: 'SplitColorChannel',\n  setMaterialValues: (material, props) => {\n    material.uniforms.uOffset.value = parseFloat(props.rgbOffset);\n    material.uniforms.uRotation.value = parseFloat(props.rotation);\n    material.uniforms.uApplyBlur.value = props.addBlur ? 1.0 : 0.0;\n    material.uniforms.uAnimateNoise.value = props.addNoise ? 1.0 : 0.0;\n  }\n});\n","import { fliesMaterial } from './materials';\nimport { createBlotterComponent } from './createBlotterComponent';\n\nexport const FliesText = createBlotterComponent({\n  material: fliesMaterial,\n  defaultProps: {\n    cellWidth: 0.04,\n    cellRadius: 0.5,\n    speed: 2.0,\n    dodge: false,\n    dodgeX: 0.5,\n    dodgeY: 0.8,\n    dodgeSpread: 0.75,\n    id: 'flies-text-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5\n  },\n  displayName: 'FliesText',\n  setMaterialValues: (material, props) => {\n    material.uniforms.uPointCellWidth.value = parseFloat(props.cellWidth);\n    material.uniforms.uPointRadius.value = parseFloat(props.cellRadius);\n    material.uniforms.uSpeed.value = parseFloat(props.speed);\n    material.uniforms.uDodge.value = props.dodge ? 1.0 : 0.0;\n    material.uniforms.uDodgePosition.value = [\n      parseFloat(props.dodgeX),\n      parseFloat(props.dodgeY)\n    ];\n    material.uniforms.uDodgeSpread.value = parseFloat(props.dodgeSpread);\n  }\n});\n","import { createBlotterComponent } from './createBlotterComponent';\nimport { liquidDistortionMaterial } from './materials';\n\nexport const LiquidDistortionText = createBlotterComponent({\n  defaultProps: {\n    id: 'liquid-distortion-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    lineHeight: 1.5,\n    speed: 1.5,\n    volatility: 0.04\n  },\n  displayName: 'LiquidDistortionText',\n  setMaterialValues: (material, props) => {\n    material.uniforms.uSpeed.value = parseFloat(props.speed);\n    material.uniforms.uVolatility.value = parseFloat(props.volatility);\n  },\n  material: liquidDistortionMaterial\n});\n","import { createBlotterComponent } from './createBlotterComponent';\nimport { distortionText } from './materials';\n\nexport const DistortionText = createBlotterComponent({\n  material: distortionText,\n  defaultProps: {\n    id: 'distortion-text-component',\n    text: 'Hello World',\n    fontFamily: 'sans-serif',\n    fontSize: 45,\n    fontWeight: 400,\n    rotation: 0.0,\n    rgbOffset: 0.05,\n    fill: '#4f4f4f',\n    fontStyle: 'normal',\n    paddingBottom: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingLeft: 0,\n    speed: 0.084,\n    rotation: 120.0,\n    distortX: 0.06,\n    distortY: 0.09,\n    noiseAmplitude: 0.101,\n    noiseVolatility: 8\n  },\n  setMaterialValues: (material, props) => {\n    material.uniforms.uNoiseDistortVolatility.value = props.noiseVolatility;\n    material.uniforms.uNoiseDistortAmplitude.value = props.noiseAmplitude;\n    material.uniforms.uDistortPosition.value = [props.distortX, props.distortY];\n    material.uniforms.uRotation.value = props.rotation;\n    material.uniforms.uSpeed.value = props.speed;\n    material.uniforms.uSineDistortSpread.value = 0;\n    material.uniforms.uSineDistortCycleCount.value = 0;\n    material.uniforms.uSineDistortAmplitude.value = 0;\n  },\n  displayName: 'DistortionText'\n});\n"]},"metadata":{},"sourceType":"module"}